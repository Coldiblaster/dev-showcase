{"snippets":{"debounce":{"title":"useDebounce Hook","description":"Verzögert die Aktualisierung eines Werts, bis der Benutzer mit der Eingabe aufhört","explanation":"**useDebounce** verzögert die Aktualisierung eines Werts, bis der Benutzer mit der Eingabe aufhört.\n\n**So funktioniert es:**\n• Akzeptiert den Wert und die Verzögerung in ms\n• Verwendet setTimeout zur Verzögerung der Aktualisierung\n• Löscht den vorherigen Timer bei jeder Änderung (cleanup im useEffect)\n• Gibt den \"debounced\" Wert zurück — aktualisiert nur nach der Verzögerung\n\n**Wann verwenden:**\n• Suchfelder (vermeidet Anfragen bei jeder Tastatureingabe)\n• Dynamische Filter\n• Auto-Save von Formularen\n\n**Performance:** Reduziert API-Aufrufe von ~10/s auf ~2/s bei normaler Eingabe."},"format-date":{"title":"Datumsformatierung (Intl API)","description":"Formatiert Datumsangaben ohne Abhängigkeiten mit der nativen Intl API","explanation":"**Datumsformatierung** mit der nativen Intl API — ohne externe Abhängigkeiten.\n\n**Vorteile der Intl API:**\n• Native Browser-API — null Bundle-Größe\n• Automatische Unterstützung für beliebige Locales\n• Funktioniert in Node.js und modernen Browsern\n\n**formatDate vs moment/date-fns:**\n• moment.js: ~70KB (veraltet)\n• date-fns: ~12KB (tree-shakeable)\n• Intl API: 0KB — bereits im Browser!\n\n**formatRelative — wann verwenden:**\n• Aktivitätsfeeds, Kommentare, Benachrichtigungen\n• Jeder Zeitstempel, der \"menschlich\" lesbar sein soll\n\n**Tipp:** Übergebe die Locale als Parameter für i18n-Unterstützung."},"use-toggle":{"title":"useToggle Hook","description":"Hook für Booleans mit benannten Aktionen — lesbarer als useState(false)","explanation":"**useToggle** ersetzt useState(false) mit einer ausdrucksvolleren und lesbareren API.\n\n**Warum besser als reiner useState:**\n• `modal.setTrue` ist klarer als `setIsOpen(true)`\n• `favorite.toggle` ist klarer als `setFav(v => !v)`\n• Aktionen sind useCallback — sicher als Props zu übergeben\n• Benannte Destrukturierung: `const modal = useToggle()`\n\n**Wann verwenden:**\n• Modals (öffnen/schließen)\n• Dropdowns und Menüs\n• Favoriten (Toggle)\n• Dark-Mode-Toggle\n• Jeder Boolean-Zustand\n\n**Pattern:** Objekt statt Array zurückgeben ermöglicht semantische Namen ohne positionsbasierte Destrukturierung."},"safe-context":{"title":"createSafeContext","description":"Erstellt Context + Hook type-safe ohne undefined-Prüfung","explanation":"**createSafeContext** eliminiert das repetitive Muster beim Erstellen von Context + Provider + Hook mit Null-Check.\n\n**Gelöstes Problem:**\n• Jeder createContext<T | undefined>(undefined) erfordert if (!ctx) throw...\n• Das in 10+ Contexts zu wiederholen = massiver Boilerplate\n• Leicht zu vergessen und führt zu Laufzeitfehlern\n\n**So funktioniert es:**\n• Erstellt den Context mit null als Standardwert\n• Der Hook useContextValue führt den Null-Check einmal aus\n• Gibt [Provider, Hook] als Tupel zurück\n\n**Warum besser als das manuelle Muster:**\n• 0 Boilerplate — 1 Zeile erstellt typisierten Provider + Hook\n• Automatische beschreibende Fehlermeldung (\"useAuth must be used within AuthProvider\")\n• displayName erscheint in den React DevTools\n\n**Pattern verwendet in:** Radix UI, shadcn/ui internals, Chakra UI."},"media-query":{"title":"useMediaQuery (SSR-sicher)","description":"Responsiver Hook, der mit SSR/Next.js ohne Hydration-Mismatch funktioniert","explanation":"**useMediaQuery** erkennt CSS-Medienabfragen in JavaScript — SSR-sicher.\n\n**Der SSR-Trick:**\n• useState(false) als Standard — Server und Client starten identisch\n• useEffect synchronisiert mit dem echten Wert im Client\n• Vermeidet Hydration-Mismatch (der nervigste Next.js-Fehler)\n\n**Warum nicht direkt CSS @media?**\n• Wenn die Logik vom Breakpoint abhängt (Komponente wechseln, nicht nur Stil)\n• Wenn der Wert in JavaScript benötigt wird (Analytics, Feature-Flags)\n• Barrierefreiheit: prefers-reduced-motion zum Deaktivieren von Animationen\n\n**Mitgelieferte Presets:**\n• Tailwind-Breakpoints (sm, md, lg, xl)\n• Dark-Mode und Reduced Motion\n• Erweiterbar — übergebe beliebige Media-Query-Strings\n\n**Vorsicht:** Nicht zum visuellen Ausblenden von Inhalt nutzen — bevorzuge CSS dafür (besser für SEO/Barrierefreiheit)."},"event-callback":{"title":"useEventCallback","description":"Stabile Funktionsreferenz ohne veraltete Closures — löst den häufigsten Hooks-Bug","explanation":"**useEventCallback** gibt eine Funktion mit stabiler Referenz zurück, die immer den aktuellsten State zugreift.\n\n**Das gelöste Problem:**\n• useCallback mit deps = Funktion wird neu erstellt = Re-Subscribe in Effects\n• useCallback ohne deps = veraltete Closure = liest alten State\n• Klassisches Dilemma, das subtile Bugs in WebSockets, Timern, Event-Listenern verursacht\n\n**So funktioniert es:**\n• useRef speichert die neueste Version der Funktion\n• ref.current wird bei jedem Render aktualisiert (sync)\n• useCallback([], ...) gibt einen stabilen Wrapper zurück, der ref.current aufruft\n• Ergebnis: stabile Referenz + immer frische Closure\n\n**Wann verwenden:**\n• Event-Handler, die an useEffect übergeben werden\n• WebSocket/SSE-Callbacks\n• Lang laufende Timer (setInterval)\n• Überall wo Stabilität + Aktualität wichtig sind\n\n**Äquivalent in React 19:** useEffectEvent (experimentell)."},"typed-fetch-zod":{"title":"Typed Fetch + Zod Validation","description":"Type-safe Fetch mit Laufzeitvalidierung — Single Source of Truth","explanation":"**typedFetch** kombiniert fetch + Zod für Validierung zur Kompilierzeit UND Laufzeit.\n\n**Warum TypeScript-Interfaces allein nicht reichen:**\n• Interface existiert nur zur Kompilierzeit — verschwindet im JavaScript\n• Ändert das Backend ein Feld, schützt TypeScript nicht\n• Der Absturz tritt weit von der Ursache auf (im Render, nicht im fetch)\n\n**Was Zod hinzufügt:**\n• Laufzeitvalidierung — Fehler an der exakten Stelle des Fetch\n• Vom Schema inferierter Typ (z.infer) — Single Source of Truth\n• Beschreibende Fehlermeldung: Feld, erwarteter vs. erhaltener Wert\n• safeParse stürzt nicht ab — du entscheidest, wie zu behandeln\n\n**Wann verwenden:**\n• Jeder Fetch einer externen API, die du nicht kontrollierst\n• Interne APIs, die sich häufig ändern\n• Kritische Daten (Zahlung, Auth, Konfiguration)\n• Integration mit Drittanbietern (Webhooks, öffentliche APIs)\n\n**Bundle:** Zod ~13KB gzipped — jeder Byte wert in Produktion."},"discriminated-props":{"title":"Discriminated Union Props","description":"TypeScript-Pattern, das die falsche Verwendung von Props unmöglich macht","explanation":"**Discriminated Union Props** nutzt das Typsystem von TypeScript, um ungültige Kombinationen unmöglich zu machen.\n\n**Das Problem mit optionalen Props:**\n• variant=\"link\" mit loading={true}? Macht das Sinn?\n• href und onClick zusammen? Welches gewinnt?\n• Optionale Props erlauben JEDE Kombination — stille Bugs\n\n**So funktioniert es:**\n• Eine \"diskriminante\" Eigenschaft (variant) bestimmt, welche Props existieren\n• `never` blockiert Props, die für diese Variante keinen Sinn machen\n• TypeScript verengt (type narrowing) innerhalb von if/switch\n\n**Wann verwenden:**\n• Komponenten mit mehreren Varianten (Button, Input, Modal)\n• Gegenseitig ausschließende Props (href vs onClick, mode vs config)\n• Komponenten-APIs für andere Entwickler\n\n**Ergebnis:** Fehler erscheinen im Editor, nicht in Produktion. Autocomplete zeigt nur gültige Props für die gewählte Variante."},"type-safe-exhaustive":{"title":"Exhaustive Switch Pattern","description":"Pattern, das zur Kompilierzeit sicherstellt, dass alle Cases einer Union behandelt wurden","explanation":"**assertNever** ist das Pattern, das vollständige Abdeckung von Union-Types zur Kompilierzeit garantiert.\n\n**Das Problem ohne es:**\n• Neuen Status/Variant/Action im Type hinzugefügt\n• Behandeln in 3 von 5 Switches der Codebase vergessen\n• Bug erscheint erst zur Laufzeit — Monate später\n\n**So funktioniert es:**\n• Der Parameter ist vom Typ `never`\n• Sind alle Cases abgedeckt, ist default unreachable = Typ `never` = OK\n• Fehlt ein Case, ist der Typ nicht `never` = Fehler zur Kompilierzeit\n\n**Wo verwenden:**\n• Reducer (useReducer, Redux)\n• Statusmaschinen (Zahlung, Bestellung, Auth)\n• Komponenten mit mehreren Varianten\n• Jeder Switch über Union-Types\n\n**Pattern übernommen von:** Effect-TS, fp-ts, Prisma, tRPC."}},"comparisons":{"key-prop":{"title":"Index als Key vs. stabile Key","category":"React Fundamentals","problem":"Index als Key in Listen verursacht stille visuelle Bugs, wenn Einträge umsortiert, entfernt oder eingefügt werden","issues":["Index ändert sich bei Umsortierung oder Entfernung von Einträgen","React wiederverwendet das DOM des alten Index — visueller Zustand stimmt nicht","Checkboxen, Inputs und Animationen brechen still","Bug erscheint nur zur Laufzeit — unmöglich im Code Review zu finden"],"improvements":["Stabile Key (id) gewährleistet korrektes DOM-Tracking","Checkboxen, Inputs und Animationen behalten ihren Zustand","Entfernung und Umsortierung funktionieren ohne visuelle Bugs","Einfache Regel: hat das Element eine id, nutze sie als Key"]},"early-returns":{"title":"Sauberes Conditional Rendering","category":"React Patterns","problem":"Verschachtelte Ifs und verkettete Ternäre machen JSX unleserlich und schwer wartbar","issues":["Ternäre verschachtelt in 4+ Ebenen","Schwer nachzuvollziehen, welche Bedingung zu welchem Ergebnis führt","Neuen Zustand hinzufügen erfordert ganze Baumstruktur neu zu schreiben","Code Review wird zum Albtraum — niemand vertraut dem Diff"],"improvements":["Early returns eliminieren jegliche Verschachtelung","Jeder Zustand (loading/error/empty) in 1 Zeile behandelt","Extrahierten Komponenten einzeln testbar","Neuen Zustand hinzufügen = 1 Zeile, ohne den Rest anzufassen"]},"custom-hooks":{"title":"useEffect Kitchen Sink vs. Custom Hooks","category":"React Hooks","problem":"Alles in einen riesigen useEffect zu werfen macht die Komponente untestbar und nicht wiederverwendbar","issues":["useEffect mischt fetch + localStorage + state — 3 Verantwortlichkeiten","Fetch nicht separat von der Komponente testbar","Favoriten-Logik nicht auf anderen Seiten wiederverwendbar","Komponente mit 60+ Zeilen vor dem return"],"improvements":["Jeder Hook hat 1 Verantwortung — testbar mit renderHook()","useFavorite auf beliebigen Seiten wiederverwendbar","AbortController verhindert Race Conditions und Memory Leaks","Finale Komponente hat ~10 Zeilen — nur Komposition"]},"error-handling":{"title":"Generischer Try/Catch vs. Error Boundaries + Result Pattern","category":"Error Handling","problem":"Generischer Try/Catch verbirgt Fehler und erschwert Recovery — Benutzer sieht weißen Bildschirm oder nutzlose Meldung","issues":["Generischer catch behandelt Netzwerkfehler, 400 und 500 gleich","Meldung 'Etwas ist schiefgelaufen' hilft dem Benutzer nicht","Console.error in Produktion — niemand sieht es","Kein Unterschied zwischen behebbarem und fatalem Fehler"],"improvements":["Result Pattern erzwingt explizite Behandlung von Erfolg und Fehler","Jeder Fehlertyp hat spezifisches Recovery (Redirect, Retry, Feldfehler)","TypeScript garantiert Behandlung aller Fehlertypen (exhaustive switch)","Ohne throw — vorhersehbarer Ablauf, keine Überraschungen in Produktion"]},"zod-validation":{"title":"API ohne Validierung vs. Zod Schema","category":"TypeScript","problem":"Zu vertrauen, dass die API das richtige Format zurückgibt, verursacht Crashes in Produktion bei Backend-Änderungen","issues":["TypeScript-Interface existiert nur zur Kompilierzeit — null Laufzeitschutz","Backend ändert ein Feld und das Frontend crasht still","Fehler erscheint weit von der Ursache (im .toUpperCase, nicht im fetch)","Ohne hilfreiche Meldung — Stack Trace zeigt auf falsche Stelle"],"improvements":["Laufzeitvalidierung — Fehler direkt am Problemort","Vom Schema inferierter TypeScript-Typ — Single Source of Truth","Beschreibende Fehlermeldung (Feld, erwarteter vs. erhaltener Wert)","safeParse crasht die App nicht — du entscheidest, wie zu behandeln"]},"typed-context":{"title":"Verstreuter State vs. typisierter Context","category":"React Patterns","problem":"useState in mehreren Komponenten verteilt verursacht Desynchronisation und Props Drilling","issues":["App-Komponente wird zum 'God Component' mit allem State","Props Drilling in Kaskade — 3+ Ebenen Weiterreichung","Neuen globalen State hinzufügen = 10+ Komponenten ändern","Unmöglich zu wissen, wer was ändert — Synchronisations-Bugs"],"improvements":["Zentralisierter State mit vorhersehbaren Übergängen (Reducer)","Komponenten greifen nur auf das Nötige zu — null Props Drilling","Typisierte Actions — ungültiger Dispatch zur Kompilierzeit unmöglich","useApp() mit Guard — klarer Fehler bei Nutzung außerhalb des Providers"]}},"patterns":{"share-state":{"question":"Ich muss State zwischen weit entfernten Komponenten teilen","pattern":"Context API + useContext","explanation":"Context ist Reacts native Methode, Prop Drilling zu vermeiden. Erstelle einen Provider auf der höchsten nötigen Ebene und nutze useContext in den Komponenten, die es brauchen.","when":["Theme, Sprache, Auth — Daten in vielen Komponenten genutzt","Props durch 3+ Ebenen vermeiden","State der sich selten ändert (geringe Update-Frequenz)"],"avoid":["State der bei jedem Tastendruck ändert (verursacht Re-Render bei allen Consumers)","Daten die nur 1–2 Komponenten nutzen (normale Prop reicht)"]},"prevent-rerender":{"question":"Meine Komponente re-rendert zu oft und die UI ist langsam","pattern":"React.memo + useMemo + useCallback","explanation":"React re-rendert eine Komponente, wenn der Vater re-rendert. memo() überspringt das Re-Render, wenn die Props sich nicht geändert haben. useMemo und useCallback stabilisieren Werte und Funktionen, damit memo funktioniert.","when":["Listen mit 100+ Einträgen, die unnötig re-rendern","Komponenten mit aufwändigen Berechnungen (sort, filter, transform)","Stabile Kind-Komponenten die Funktionen als Props erhalten"],"avoid":["Vorzeitige Optimierung — messe zuerst mit React DevTools Profiler","memo() bei Komponenten die IMMER unterschiedliche Props bekommen","useMemo/useCallback für einfache Werte (Overhead lohnt sich nicht)"]},"form-validation":{"question":"Ich muss komplexe Formulare mit guter UX validieren","pattern":"React Hook Form + Zod","explanation":"React Hook Form verwaltet den Formular-State ohne unnötige Re-Renders. Zod definiert das Validierungsschema und inferiert den TypeScript-Typ automatisch.","when":["Formulare mit 3+ Feldern und Validierungsregeln","Validierung in Echtzeit (on blur/change)","Formulare die Performance brauchen (kein Re-Render bei jedem Tastendruck)"],"avoid":["Einfache Formulare mit 1–2 Feldern (useState reicht)","Wenn keine clientseitige Validierung nötig ist"]},"async-state":{"question":"Ich muss asynchronen State verwalten (loading, error, data)","pattern":"TanStack Query (React Query)","explanation":"TanStack Query verwaltet den gesamten Lebenszyklus remote Daten: Fetch, Cache, Revalidierung, Retry, optimistische Updates. Eliminiert useState + useEffect für Datenabruf.","when":["Jeder API-Fetch der Cache und Revalidierung braucht","Listen mit Pagination, Infinite Scroll oder Polling","Mutations die den lokalen Cache aktualisieren müssen"],"avoid":["Statische Daten die sich nie ändern (direkt importieren oder getStaticProps nutzen)","Rein clientseitiger State (Form-State, UI-Toggles)"]},"type-narrowing":{"question":"Ich muss unterschiedliche Antworttypen sicher verarbeiten","pattern":"Discriminated Unions + Type Narrowing","explanation":"Discriminated Unions nutzen eine Literal-Eigenschaft (type, status, kind), damit TypeScript automatisch weiß, welche Variante welche ist, innerhalb von switch/if.","when":["API-Antworten mit mehreren Formaten (success/error/loading)","Komponenten mit gegenseitig ausschließenden Varianten","State Machines (Bestellung: ausstehend → verarbeitend → abgeschlossen → storniert)"],"avoid":["Wenn der Typ einfach ist und keine Varianten hat (einfachen Type Guard nutzen)","Wenn alle Eigenschaften immer vorhanden sind (normale Interface reicht)"]},"render-optimization":{"question":"Ich muss eine Liste mit tausenden Einträgen rendern","pattern":"Virtualisierung mit TanStack Virtual","explanation":"Virtualisierung rendert nur die in der Viewport sichtbaren Einträge. Statt 10.000 DOM-Nodes werden ~20 gerendert. Der Performance-Unterschied ist massiv.","when":["Listen mit 500+ Einträgen (Tabellen, Feeds, Logs)","Wenn Scroll langsam oder ruckelig wird","Listen mit variabler Eintragshöhe (estimateSize)"],"avoid":["Listen mit weniger als ~100 Einträgen (Overhead lohnt sich nicht)","Wenn SEO für alle Einträge nötig ist (Virtualisierung versteckt vor dem Crawler)"]},"conditional-style":{"question":"Ich muss bedingte Styles anwenden ohne das JSX zu verwirren","pattern":"clsx/cn + Tailwind Variants","explanation":"Die Funktion cn() (clsx + tailwind-merge) verbindet Klassen bedingt und löst Tailwind-Konflikte. Standard bei shadcn/ui und der gesamten Tailwind-Community.","when":["Jede Komponente mit Styles die sich nach State oder Prop ändern","Wiederverwendbare Komponenten die externe className akzeptieren müssen","Design-Systeme mit mehreren Varianten (button, badge, alert)"],"avoid":["Styles die sich nie ändern (statische Klassen direkt nutzen)","Sehr komplexe Stylogik (CSS Modules oder styled-components erwägen)"]},"fetch-data":{"question":"Was ist die beste Methode, Daten in einer Komponente zu laden?","pattern":"useEffect + fetch (Basis) oder Server Components (Next.js)","explanation":"Für Datenabruf nutze useEffect mit fetch in Client-Komponenten oder nutze Next.js Server Components für serverseitigen Abruf ohne JavaScript im Client.","when":["Jede Komponente die Daten einer API anzeigen muss","Server Components: statische oder serverseitig ladbare Daten","Client Components: Daten die von Benutzerinteraktion abhängen"],"avoid":["Fetch in Event-Handlern (für Aktionen nutzen, nicht für initiale Daten)","Fetch ohne AbortController in useEffect (verursacht Memory Leaks)"]},"error-recovery":{"question":"Wie implementiere ich graziöses Error Recovery in Produktion?","pattern":"Error Boundaries + Suspense + Retry Pattern","explanation":"Kombiniere Error Boundaries für Render-Fehler, Suspense für Lade-Zustände und ein Retry-Pattern, damit der Benutzer erneut versuchen kann ohne die Seite neu zu laden.","when":["Dashboards mit mehreren unabhängigen Sektionen","Komponenten die von externen APIs abhängen (können fehlschlagen)","Jede Produktions-App die Resilienz braucht"],"avoid":["Fehler in Event-Handlern (Error Boundaries fangen nicht — try/catch nutzen)","Fehler in asynchronem Code außerhalb des Renders (Result Pattern nutzen)"]}},"quickTips":{"key-unique":{"tip":"Nutze niemals Index als Key in Listen die sich ändern","detail":"Verwende eine eindeutige stabile ID (z.B. DB-id). Index verursacht stille visuelle Bugs bei Umsortierung oder Entfernung — React wiederverwendet das falsche DOM.","category":"React"},"optional-chaining":{"tip":"Nutze optional chaining (?.) statt verkettetem &&","detail":"user?.address?.city ist cleaner und sicherer als user && user.address && user.address.city. Funktioniert auch mit Methodenaufrufen: obj.method?.()","category":"JavaScript"},"fragment-div":{"tip":"Nutze <></> statt <div> wenn nur JSX gruppiert werden soll","detail":"Fragments erzeugen keinen zusätzlichen DOM-Knoten. Unnötige Divs brechen CSS-Layouts (flex, grid) und belasten die DOM-Struktur ohne Grund.","category":"React"},"const-let":{"tip":"Bevorzuge const immer — nutze let nur bei echter Neuzuweisung","detail":"const kommuniziert Absicht: dieser Wert ändert sich nicht. Erleichtert Code Review und vermeidet versehentliche Neuzuweisungen. In ~95% der Fälle reicht const.","category":"JavaScript"},"updater-function":{"tip":"Nutze Updater-Funktion bei setState wenn vom vorherigen Wert abhängig","detail":"setCount(count + 1) kann veralteten Wert bei gebatchten Updates nutzen. setCount(prev => prev + 1) nutzt immer den neuesten Wert. Essenziell in asynchronen Event-Handlern.","category":"React"},"abort-controller":{"tip":"Nutze immer AbortController bei Fetches innerhalb von useEffect","detail":"Ohne Abort verursacht schnelles Navigieren Race Conditions — die Antwort des vorherigen Fetches überschreibt die neue. AbortController bricht ausstehende Requests im Cleanup ab.","category":"Performance"},"as-const":{"tip":"Nutze 'as const' für literal Typ-Inferenz statt generischem string","detail":"const roles = ['admin', 'user'] as const inferiert den readonly ['admin', 'user'] Typ statt string[]. Ermöglicht Union-Typen: type Role = typeof roles[number]","category":"TypeScript"},"error-boundary":{"tip":"Umschließe Routen und unabhängige Sektionen immer mit Error Boundaries","detail":"Ein Fehler in einer Kind-Komponente wirft den gesamten React-Baum. Error Boundaries isolieren Crashes — die Sidebar kann abstürzen ohne die ganze Seite mitzureißen.","category":"React"},"barrel-files":{"tip":"Vermeide Barrel-Files (index.ts) in großen Projekten — sie zerstören Tree-Shaking","detail":"Import aus index.ts zwingt den Bundler alle Re-Exports auszuwerten. In Monorepos können hunderte KB zum Bundle hinzukommen. Importiere direkt aus der Quelldatei.","category":"Architecture"},"server-components":{"tip":"Komponenten die nur Daten anzeigen sollten Server Components sein — füge 'use client' nicht unnötig hinzu","detail":"Server Components laufen auf dem Server = null JavaScript im Client-Bundle. Füge 'use client' nur hinzu bei Hooks, Event-Handlern oder Browser-APIs.","category":"Next.js"},"composition-over-config":{"tip":"Bevorzuge Komposition über Konfiguration bei öffentlichen Komponenten","detail":"Statt <Card showHeader showFooter headerTitle='...' footerAction='...'> nutze <Card><CardHeader>...</CardHeader><CardFooter>...</CardFooter></Card>. Flexibler, typisiert und erweiterbar.","category":"Patterns"},"use-sync-external-store":{"tip":"Nutze useSyncExternalStore um externe Stores mit React 18+ zu integrieren","detail":"Der offizielle Hook um React mit beliebigen externen Datenquellen zu synchronisieren (localStorage, WebSocket, Redux-ähnliche Stores). Gewährleistet Konsistenz mit Concurrent Rendering.","category":"React"}}}
