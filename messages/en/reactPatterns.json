{
  "hero": {
    "badge": "Practical Guide",
    "title": "React Design Patterns",
    "subtitle": "// architecture, composition and best practices",
    "description": "Architectural React patterns used in professional projects: Compound Components, Custom Hooks, Render Props, HOCs and more — with practical examples."
  },
  "sectionNav": {
    "composition": "Composition",
    "hooks": "Custom Hooks",
    "statePatterns": "State",
    "performance": "Performance"
  },
  "composition": {
    "title": "Composition & Components",
    "subtitle": "// patterns for flexible components",
    "description": "Patterns that make your components more flexible, reusable and easy to maintain.",
    "items": [
      {
        "name": "Compound Components",
        "description": "Components that work together sharing implicit state via Context. Enables declarative and flexible API.",
        "code": "// Declarative and clean API\n<Select>\n  <Select.Trigger>Choose an option</Select.Trigger>\n  <Select.Content>\n    <Select.Item value=\"react\">React</Select.Item>\n    <Select.Item value=\"vue\">Vue</Select.Item>\n    <Select.Item value=\"angular\">Angular</Select.Item>\n  </Select.Content>\n</Select>\n\n// Implementation with Context\nconst SelectContext = createContext<SelectState | null>(null);\n\nfunction Select({ children }: { children: ReactNode }) {\n  const [value, setValue] = useState('');\n  return (\n    <SelectContext.Provider value={{ value, setValue }}>\n      {children}\n    </SelectContext.Provider>\n  );\n}\n\nSelect.Trigger = function Trigger({ children }) { /* ... */ };\nSelect.Content = function Content({ children }) { /* ... */ };\nSelect.Item = function Item({ value, children }) { /* ... */ };",
        "useCases": ["Selects, Tabs, Accordions", "Menus and Dropdowns", "Composite Form Fields"]
      },
      {
        "name": "Render Props",
        "description": "Pass a function as prop (or children) that receives data and returns JSX. Useful for injecting logic without imposing UI.",
        "code": "// Component provides data, consumer decides UI\nfunction MouseTracker({ children }: {\n  children: (pos: { x: number; y: number }) => ReactNode\n}) {\n  const [pos, setPos] = useState({ x: 0, y: 0 });\n\n  useEffect(() => {\n    const handler = (e: MouseEvent) =>\n      setPos({ x: e.clientX, y: e.clientY });\n    window.addEventListener('mousemove', handler);\n    return () => window.removeEventListener('mousemove', handler);\n  }, []);\n\n  return <>{children(pos)}</>;\n}\n\n// Usage\n<MouseTracker>\n  {({ x, y }) => (\n    <div>Mouse: {x}, {y}</div>\n  )}\n</MouseTracker>",
        "useCases": ["Data injection without imposing layout", "Headless components", "Form libraries"]
      },
      {
        "name": "Container / Presentational",
        "description": "Separate logic (Container) from presentation (Presentational). Container fetches data and manages state, Presentational only renders.",
        "code": "// Container — logic and data\nfunction UserListContainer() {\n  const { data, isLoading } = useQuery({\n    queryKey: ['users'],\n    queryFn: fetchUsers\n  });\n\n  if (isLoading) return <Skeleton />;\n  return <UserList users={data ?? []} />;\n}\n\n// Presentational — UI only, no logic\nfunction UserList({ users }: { users: User[] }) {\n  return (\n    <ul>\n      {users.map(user => (\n        <li key={user.id}>{user.name}</li>\n      ))}\n    </ul>\n  );\n}",
        "useCases": ["Separation of concerns", "Testable components", "Visual layer reuse"]
      }
    ],
    "useCasesLabel": "When to use"
  },
  "hooks": {
    "title": "Custom Hooks",
    "subtitle": "// extract and reuse logic",
    "description": "Custom hooks encapsulate reusable logic. They are the most idiomatic way to share behavior between components in React.",
    "items": [
      {
        "name": "useLocalStorage",
        "description": "Persists state in localStorage with automatic synchronization.",
        "code": "function useLocalStorage<T>(key: string, initial: T) {\n  const [value, setValue] = useState<T>(() => {\n    if (typeof window === 'undefined') return initial;\n    const stored = localStorage.getItem(key);\n    return stored ? JSON.parse(stored) : initial;\n  });\n\n  useEffect(() => {\n    localStorage.setItem(key, JSON.stringify(value));\n  }, [key, value]);\n\n  return [value, setValue] as const;\n}\n\n// Usage\nconst [theme, setTheme] = useLocalStorage('theme', 'dark');"
      },
      {
        "name": "useDebounce",
        "description": "Delays value updates — ideal for search and inputs.",
        "code": "function useDebounce<T>(value: T, delay: number): T {\n  const [debounced, setDebounced] = useState(value);\n\n  useEffect(() => {\n    const timer = setTimeout(() => setDebounced(value), delay);\n    return () => clearTimeout(timer);\n  }, [value, delay]);\n\n  return debounced;\n}\n\n// Usage\nconst [search, setSearch] = useState('');\nconst debouncedSearch = useDebounce(search, 300);\n\nuseEffect(() => {\n  fetchResults(debouncedSearch);\n}, [debouncedSearch]);"
      },
      {
        "name": "useMediaQuery",
        "description": "Reacts to media query changes (responsiveness) in JavaScript.",
        "code": "function useMediaQuery(query: string): boolean {\n  const [matches, setMatches] = useState(false);\n\n  useEffect(() => {\n    const media = window.matchMedia(query);\n    setMatches(media.matches);\n\n    const listener = (e: MediaQueryListEvent) =>\n      setMatches(e.matches);\n    media.addEventListener('change', listener);\n    return () => media.removeEventListener('change', listener);\n  }, [query]);\n\n  return matches;\n}\n\n// Usage\nconst isMobile = useMediaQuery('(max-width: 768px)');"
      },
      {
        "name": "useClickOutside",
        "description": "Detects clicks outside an element — perfect for modals and dropdowns.",
        "code": "function useClickOutside(\n  ref: RefObject<HTMLElement | null>,\n  handler: () => void\n) {\n  useEffect(() => {\n    const listener = (e: MouseEvent | TouchEvent) => {\n      if (!ref.current?.contains(e.target as Node)) {\n        handler();\n      }\n    };\n    document.addEventListener('mousedown', listener);\n    document.addEventListener('touchstart', listener);\n    return () => {\n      document.removeEventListener('mousedown', listener);\n      document.removeEventListener('touchstart', listener);\n    };\n  }, [ref, handler]);\n}\n\n// Usage\nconst ref = useRef<HTMLDivElement>(null);\nuseClickOutside(ref, () => setOpen(false));"
      }
    ]
  },
  "statePatterns": {
    "title": "State Patterns",
    "subtitle": "// manage state in a scalable way",
    "description": "Patterns for managing complex state in an organized and predictable way.",
    "items": [
      {
        "name": "Reducer Pattern",
        "description": "Use useReducer for complex state with multiple actions. More predictable than multiple useState.",
        "before": "// Multiple useState — hard to maintain\nconst [items, setItems] = useState([]);\nconst [loading, setLoading] = useState(false);\nconst [error, setError] = useState(null);\nconst [page, setPage] = useState(1);\n\n// Updates scattered across component\nsetLoading(true);\nsetError(null);\nfetch(url)\n  .then(data => { setItems(data); setLoading(false); })\n  .catch(err => { setError(err); setLoading(false); });",
        "after": "type Action =\n  | { type: 'FETCH_START' }\n  | { type: 'FETCH_SUCCESS'; payload: Item[] }\n  | { type: 'FETCH_ERROR'; error: string }\n  | { type: 'NEXT_PAGE' };\n\nfunction reducer(state: State, action: Action): State {\n  switch (action.type) {\n    case 'FETCH_START':\n      return { ...state, loading: true, error: null };\n    case 'FETCH_SUCCESS':\n      return { ...state, items: action.payload, loading: false };\n    case 'FETCH_ERROR':\n      return { ...state, error: action.error, loading: false };\n    case 'NEXT_PAGE':\n      return { ...state, page: state.page + 1 };\n  }\n}\n\nconst [state, dispatch] = useReducer(reducer, initialState);"
      },
      {
        "name": "Context + Provider Pattern",
        "description": "Share global state with type safety via Context. Avoids prop drilling in deep trees.",
        "before": "// Prop drilling — 4 levels deep\n<App user={user} />\n  <Layout user={user} />\n    <Sidebar user={user} />\n      <UserMenu user={user} />\n        <Avatar name={user.name} />",
        "after": "// Context eliminates prop drilling\nconst UserContext = createContext<User | null>(null);\n\nfunction useUser() {\n  const user = useContext(UserContext);\n  if (!user) throw new Error('useUser must be within Provider');\n  return user;\n}\n\nfunction UserProvider({ children }: { children: ReactNode }) {\n  const [user, setUser] = useState<User | null>(null);\n  return (\n    <UserContext.Provider value={user}>\n      {children}\n    </UserContext.Provider>\n  );\n}\n\n// Any level accesses directly\nfunction Avatar() {\n  const user = useUser();\n  return <img src={user.avatar} />;\n}"
      }
    ],
    "before": "Before",
    "after": "After",
    "withPattern": "✅ with pattern",
    "withoutPattern": "❌ without pattern"
  },
  "performance": {
    "title": "Performance Patterns",
    "subtitle": "// optimize renders and loading",
    "description": "Techniques to avoid unnecessary re-renders and optimize loading.",
    "items": [
      {
        "name": "React.memo + useCallback",
        "description": "Avoid re-renders of child components when props don't change.",
        "code": "// Memoized component — only re-renders when props change\nconst ExpensiveList = memo(function ExpensiveList({\n  items,\n  onItemClick,\n}: {\n  items: Item[];\n  onItemClick: (id: string) => void;\n}) {\n  return (\n    <ul>\n      {items.map(item => (\n        <li key={item.id} onClick={() => onItemClick(item.id)}>\n          {item.name}\n        </li>\n      ))}\n    </ul>\n  );\n});\n\n// Parent stabilizes function reference\nfunction Parent() {\n  const [items] = useState(fetchItems());\n\n  const handleClick = useCallback((id: string) => {\n    console.log('clicked', id);\n  }, []);\n\n  return <ExpensiveList items={items} onItemClick={handleClick} />;\n}"
      },
      {
        "name": "useMemo for Heavy Calculations",
        "description": "Memoize results of expensive calculations to avoid recomputation on every render.",
        "code": "function Dashboard({ transactions }: { transactions: Transaction[] }) {\n  // Only recalculates when transactions changes\n  const stats = useMemo(() => ({\n    total: transactions.reduce((sum, t) => sum + t.amount, 0),\n    average: transactions.reduce((sum, t) => sum + t.amount, 0)\n      / transactions.length,\n    max: Math.max(...transactions.map(t => t.amount)),\n    byCategory: groupBy(transactions, 'category'),\n  }), [transactions]);\n\n  return (\n    <div>\n      <StatCard label=\"Total\" value={stats.total} />\n      <StatCard label=\"Average\" value={stats.average} />\n    </div>\n  );\n}"
      },
      {
        "name": "Lazy Loading + Suspense",
        "description": "Load heavy components on demand to reduce initial bundle size.",
        "code": "import { lazy, Suspense } from 'react';\n\n// Loaded only when needed\nconst HeavyChart = lazy(() => import('./HeavyChart'));\nconst MarkdownEditor = lazy(() => import('./MarkdownEditor'));\n\nfunction App() {\n  const [showChart, setShowChart] = useState(false);\n\n  return (\n    <div>\n      <button onClick={() => setShowChart(true)}>\n        Show Chart\n      </button>\n\n      {showChart && (\n        <Suspense fallback={<Skeleton className=\"h-64\" />}>\n          <HeavyChart data={data} />\n        </Suspense>\n      )}\n    </div>\n  );\n}"
      }
    ]
  },
  "cta": {
    "title": "Ready for advanced React?",
    "description": "Explore more guides and practical tools for developers.",
    "button": "Back to Tips"
  }
}
