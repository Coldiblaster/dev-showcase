{"snippets":{"debounce":{"title":"useDebounce Hook","description":"Delays value updates until the user stops typing","explanation":"**useDebounce** delays updating a value until the user stops typing.\n\n**How it works:**\n• Accepts the value and delay in ms\n• Uses setTimeout to delay the update\n• Clears the previous timer on each change (useEffect cleanup)\n• Returns the \"debounced\" value — only updates after the delay\n\n**When to use:**\n• Search fields (avoids requests on every keystroke)\n• Dynamic filters\n• Form auto-save\n\n**Performance:** Reduces API calls from ~10/s to ~2/s during normal typing."},"format-date":{"title":"Date Formatter (Intl API)","description":"Format dates without dependencies using the native Intl API","explanation":"**Date formatters** using the native Intl API — no external dependencies.\n\n**Intl API advantages:**\n• Native to the browser — zero bundle size\n• Automatic support for any locale\n• Works in Node.js and modern browsers\n\n**formatDate vs moment/date-fns:**\n• moment.js: ~70KB (deprecated)\n• date-fns: ~12KB (tree-shakeable)\n• Intl API: 0KB — already in the browser!\n\n**formatRelative — when to use:**\n• Activity feeds, comments, notifications\n• Any timestamp that needs to be \"human readable\"\n\n**Tip:** Pass the locale as a parameter for i18n support."},"use-toggle":{"title":"useToggle Hook","description":"Hook for booleans with named actions — more readable than useState(false)","explanation":"**useToggle** replaces useState(false) with a more expressive and readable API.\n\n**Why it's better than plain useState:**\n• `modal.setTrue` is clearer than `setIsOpen(true)`\n• `favorite.toggle` is clearer than `setFav(v => !v)`\n• Actions are useCallback — safe to pass as props\n• Named destructuring: `const modal = useToggle()`\n\n**When to use:**\n• Modals (open/close)\n• Dropdowns and menus\n• Favorites (toggle)\n• Dark mode toggle\n• Any boolean state\n\n**Pattern:** Returning an object instead of an array allows semantic names without positional destructuring."},"safe-context":{"title":"createSafeContext","description":"Creates type-safe context + hook without needing to check for undefined","explanation":"**createSafeContext** eliminates the repetitive pattern of creating context + provider + hook with null check.\n\n**Problem it solves:**\n• Every createContext<T | undefined>(undefined) requires if (!ctx) throw...\n• Repeating this across 10+ contexts = massive boilerplate\n• Easy to forget the check and get a runtime error\n\n**How it works:**\n• Creates the context with null as default\n• The useContextValue hook performs the null check once\n• Returns [Provider, Hook] as a tuple\n\n**Why it's better than the manual pattern:**\n• 0 boilerplate — 1 line creates Provider + typed Hook\n• Automatic descriptive error (\"useAuth must be used within AuthProvider\")\n• displayName shows up in React DevTools\n\n**Pattern used in:** Radix UI, shadcn/ui internals, Chakra UI."},"media-query":{"title":"useMediaQuery (SSR-safe)","description":"Responsive hook that works with SSR/Next.js without hydration mismatch","explanation":"**useMediaQuery** detects CSS media queries in JavaScript — SSR-safe.\n\n**The SSR trick:**\n• useState(false) as default — server and client start the same\n• useEffect syncs with the actual value on the client\n• Avoids hydration mismatch (the most annoying Next.js error)\n\n**Why not use CSS @media directly?**\n• When logic depends on the breakpoint (change component, not just style)\n• When you need the value in JavaScript (analytics, feature flags)\n• Accessibility: prefers-reduced-motion to disable animations\n\n**Included presets:**\n• Tailwind breakpoints (sm, md, lg, xl)\n• Dark mode and reduced motion\n• Extensible — pass any media query string\n\n**Caution:** Don't use for hiding content visually — prefer CSS for that (better for SEO/accessibility)."},"event-callback":{"title":"useEventCallback","description":"Stable function reference without stale closures — solves the most common hooks bug","explanation":"**useEventCallback** returns a function with a stable reference that always accesses the latest state.\n\n**Problem it solves:**\n• useCallback with deps = re-creates function = re-subscribe in effects\n• useCallback without deps = stale closure = reads old state\n• Classic dilemma that causes subtle bugs in WebSockets, timers, event listeners\n\n**How it works:**\n• useRef stores the latest version of the function\n• ref.current is updated on every render (sync)\n• useCallback([], ...) returns stable wrapper that calls ref.current\n• Result: stable reference + always fresh closure\n\n**When to use:**\n• Event handlers passed to useEffect\n• WebSocket/SSE callbacks\n• Long-running timers (setInterval)\n• Any place where stability + freshness matter\n\n**React 19 equivalent:** useEffectEvent (experimental)."},"typed-fetch-zod":{"title":"Typed Fetch + Zod Validation","description":"Type-safe fetch with runtime validation — single source of truth","explanation":"**typedFetch** combines fetch + Zod for compile time AND runtime validation.\n\n**Why TypeScript interfaces aren't enough:**\n• Interfaces only exist at compile time — they disappear in JavaScript\n• If the backend changes a field, TypeScript won't protect you\n• The crash appears far from the real cause (in render, not in fetch)\n\n**What Zod adds:**\n• Runtime validation — error at the exact point of the fetch\n• Type inferred from schema (z.infer) — single source of truth\n• Descriptive message: field, expected vs received value\n• safeParse doesn't crash — you decide how to handle\n\n**When to use:**\n• Any fetch from external APIs you don't control\n• Internal APIs that change frequently\n• Critical data (payment, auth, configuration)\n• Third-party integrations (webhooks, public APIs)\n\n**Bundle:** Zod ~13KB gzipped — worth every byte in production."},"discriminated-props":{"title":"Discriminated Union Props","description":"TypeScript pattern that makes props impossible to use incorrectly","explanation":"**Discriminated Union Props** uses the TypeScript type system to make invalid combinations impossible.\n\n**Problem with optional props:**\n• variant=\"link\" with loading={true}? Does that make sense?\n• href and onClick together? Which wins?\n• Optional props allow ANY combination — silent bugs\n\n**How it works:**\n• A \"discriminant\" property (variant) determines which props exist\n• `never` blocks props that don't make sense for that variant\n• TypeScript narrows within the if/switch\n\n**When to use:**\n• Components with multiple variants (Button, Input, Modal)\n• Mutually exclusive props (href vs onClick, mode vs config)\n• Component APIs that will be used by other devs\n\n**Result:** Errors show up in the editor, not in production. Autocomplete only shows valid props for the chosen variant."},"type-safe-exhaustive":{"title":"Exhaustive Switch Pattern","description":"Pattern that guarantees at compile time that all union cases are handled","explanation":"**assertNever** is the pattern that guarantees complete union type coverage at compile time.\n\n**Problem without it:**\n• Add a new status/variant/action to the type\n• Forget to handle it in 3 of the 5 switches in the codebase\n• Bug only appears at runtime — months later\n\n**How it works:**\n• The parameter is of type `never`\n• If all cases are covered, the default is unreachable = type `never` = OK\n• If a case is missing, the type isn't `never` = compile time error\n\n**Where to use:**\n• Reducers (useReducer, Redux)\n• State machines (payment, order, auth)\n• Components with multiple variants\n• Any switch over union types\n\n**Pattern adopted by:** Effect-TS, fp-ts, Prisma, tRPC."}},"comparisons":{"key-prop":{"title":"Index as Key vs Stable Key","category":"React Fundamentals","problem":"Using index as key in lists causes silent visual bugs when items are reordered, removed, or inserted","issues":["Index changes when items are reordered or removed","React reuses the DOM from the old index — visual state gets wrong","Checkboxes, inputs, and animations break silently","Bug only appears at runtime — impossible to catch in code review"],"improvements":["Stable key (id) ensures correct DOM tracking","Checkboxes, inputs, and animations preserve state","Removal and reordering work without visual bugs","Simple rule: if the item has an id, use it as key"]},"early-returns":{"title":"Clean Conditional Rendering","category":"React Patterns","problem":"Nested ifs and chained ternaries make JSX unreadable and hard to maintain","issues":["Ternaries nested 4+ levels deep","Hard to trace which condition leads to which result","Adding a new state requires rewriting the entire tree","Code review becomes a nightmare — no one trusts the diff"],"improvements":["Early returns eliminate all nesting","Each state (loading/error/empty) handled in 1 line","Extracted components are testable in isolation","Adding new state = 1 line, without touching the rest"]},"custom-hooks":{"title":"useEffect Kitchen Sink vs Custom Hooks","category":"React Hooks","problem":"All logic dumped into one giant useEffect makes the component untestable and impossible to reuse","issues":["useEffect mixes fetch + localStorage + state — 3 responsibilities","Impossible to test fetch separately from the component","Favorite logic isn't reusable on other pages","Component with 60+ lines before the return"],"improvements":["Each hook has 1 responsibility — testable with renderHook()","useFavorite reusable on any page","AbortController prevents race conditions and memory leaks","Final component has ~10 lines — just composition"]},"error-handling":{"title":"Generic Try/Catch vs Error Boundaries + Result Pattern","category":"Error Handling","problem":"Generic try/catch hides errors and makes recovery difficult — the user sees a white screen or useless message","issues":["Generic catch treats network error, 400 and 500 the same way","'Something went wrong' message doesn't help the user fix it","Console.error in production — no one sees it","No distinction between recoverable and fatal errors"],"improvements":["Result pattern forces explicit handling of success and error","Each error type has specific recovery (redirect, retry, field errors)","TypeScript ensures all error types are handled (exhaustive switch)","No throw — predictable flow, no surprises in production"]},"zod-validation":{"title":"Unvalidated API vs Zod Schema","category":"TypeScript","problem":"Trusting that the API returns the correct format causes crashes in production when the backend changes","issues":["TypeScript interface only exists at compile time — zero runtime protection","Backend changes a field and the frontend crashes silently","Error appears far from the real cause (in .toUpperCase, not in fetch)","No useful message — stack trace points to the wrong place"],"improvements":["Runtime validation — catch at the exact point of the problem","TypeScript type inferred from schema — single source of truth","Descriptive error message (field, expected vs received value)","safeParse doesn't crash the app — you decide how to handle"]},"typed-context":{"title":"Scattered State vs Typed Context","category":"React Patterns","problem":"useState scattered across multiple components causes desynchronization and props drilling","issues":["App component becomes a 'God component' with all the state","Props drilling in cascade — 3+ levels of passing down","Adding new global state = changing 10+ components","Impossible to know who modifies what — synchronization bugs"],"improvements":["Centralized state with predictable transitions (reducer)","Components access only what they need — zero props drilling","Typed actions — impossible to dispatch invalid in compile time","useApp() with guard — clear error if used outside Provider"]}},"patterns":{"share-state":{"question":"I need to share state between distant components","pattern":"Context API + useContext","explanation":"Context is React's native way to avoid prop drilling. Create a Provider at the highest necessary level and consume with useContext in components that need it.","when":["Theme, language, auth — data used in many components","Avoid passing props through 3+ levels","State that changes little (low update frequency)"],"avoid":["State that changes on every keystroke (causes re-render in all consumers)","Data that only 1-2 components use (normal prop is enough)"]},"prevent-rerender":{"question":"My component re-renders too much and the UI is slow","pattern":"React.memo + useMemo + useCallback","explanation":"React re-renders a component when its parent re-renders. memo() skips the re-render if props haven't changed. useMemo and useCallback stabilize values and functions so memo works.","when":["Lists with 100+ items that re-render unnecessarily","Components with expensive calculations (sort, filter, transform)","Stable child components that receive functions as props"],"avoid":["Premature optimization — measure first with React DevTools Profiler","memo() on components that ALWAYS receive different props","useMemo/useCallback for simple values (overhead isn't worth it)"]},"form-validation":{"question":"I need to validate complex forms with good UX","pattern":"React Hook Form + Zod","explanation":"React Hook Form manages form state without unnecessary re-renders. Zod defines the validation schema and infers the TypeScript type automatically.","when":["Forms with 3+ fields and validation rules","Real-time validation (on blur/change)","Forms that need performance (no re-render on every keystroke)"],"avoid":["Simple forms with 1-2 fields (useState is enough)","When you don't need client-side validation"]},"async-state":{"question":"I need to manage async state (loading, error, data)","pattern":"TanStack Query (React Query)","explanation":"TanStack Query manages the entire lifecycle of remote data: fetch, cache, revalidation, retry, optimistic updates. Eliminates useState + useEffect for data fetching.","when":["Any API fetch that needs cache and revalidation","Lists with pagination, infinite scroll, or polling","Mutations that need to update local cache"],"avoid":["Static data that never changes (import directly or use getStaticProps)","Purely client-side state (form state, UI toggles)"]},"type-narrowing":{"question":"I need to handle different response types safely","pattern":"Discriminated Unions + Type Narrowing","explanation":"Discriminated unions use a literal property (type, status, kind) so TypeScript automatically knows which variant is which inside a switch/if.","when":["API responses with multiple formats (success/error/loading)","Components with mutually exclusive variants","State machines (order: pending → processing → completed → cancelled)"],"avoid":["When the type is simple with no variants (use simple type guard)","When all properties are always present (normal interface is enough)"]},"render-optimization":{"question":"I need to render a list with thousands of items","pattern":"Virtualization with TanStack Virtual","explanation":"Virtualization only renders items visible in the viewport. Instead of 10,000 DOM nodes, it renders ~20. The performance difference is massive.","when":["Lists with 500+ items (tables, feeds, logs)","When scroll feels slow or janky","Lists with variable height items (estimateSize)"],"avoid":["Lists with fewer than ~100 items (overhead isn't worth it)","When you need SEO on all items (virtualization hides from crawler)"]},"conditional-style":{"question":"I need to apply conditional styles without cluttering the JSX","pattern":"clsx/cn + Tailwind Variants","explanation":"The cn() function (clsx + tailwind-merge) concatenates classes conditionally and resolves Tailwind conflicts. It's the standard used by shadcn/ui and the Tailwind community.","when":["Any component with styles that change by state or prop","Reusable components that need to accept external className","Design systems with multiple variants (button, badge, alert)"],"avoid":["Styles that never change (use static classes directly)","Overly complex style logic (consider CSS Modules or styled-components)"]},"fetch-data":{"question":"What's the best way to fetch data in a component?","pattern":"useEffect + fetch (basic) or Server Components (Next.js)","explanation":"To fetch data, use useEffect with fetch in client-side components, or leverage Next.js Server Components to fetch on the server without JavaScript on the client.","when":["Any component that needs to display data from an API","Server Components: static data or data that can be fetched on the server","Client Components: data that depends on user interaction"],"avoid":["Fetch inside event handlers (use for actions, not initial data)","Fetch without AbortController in useEffect (causes memory leaks)"]},"error-recovery":{"question":"How do I implement graceful error recovery in production?","pattern":"Error Boundaries + Suspense + Retry Pattern","explanation":"Combine Error Boundaries to catch render errors, Suspense for loading states, and a retry pattern to give users the option to try again without reloading the page.","when":["Dashboards with multiple independent sections","Components that depend on external APIs (can fail)","Any production app that needs resilience"],"avoid":["Errors in event handlers (Error Boundaries don't catch — use try/catch)","Errors in async code outside render (use Result pattern)"]}},"quickTips":{"key-unique":{"tip":"Never use index as key in lists that change","detail":"Use a unique, stable ID (like a database id). Index causes silent visual bugs when items are reordered or removed — React reuses the wrong DOM.","category":"React"},"optional-chaining":{"tip":"Use optional chaining (?.) instead of chained &&","detail":"user?.address?.city is cleaner and safer than user && user.address && user.address.city. Works with function calls too: obj.method?.()","category":"JavaScript"},"fragment-div":{"tip":"Use <></> instead of <div> when you only need to group JSX","detail":"Fragments don't create an extra DOM node. Unnecessary divs break CSS layouts (flex, grid) and pollute the DOM tree for no reason.","category":"React"},"const-let":{"tip":"Prefer const always — only use let when you really need to reassign","detail":"const communicates intent: this value doesn't change. Makes code review easier and avoids accidental reassignments. In ~95% of cases, const is sufficient.","category":"JavaScript"},"updater-function":{"tip":"Use updater function in setState when it depends on previous value","detail":"setCount(count + 1) can use stale value in batched updates. setCount(prev => prev + 1) always uses the latest value. Essential in async event handlers.","category":"React"},"abort-controller":{"tip":"Always use AbortController in fetches inside useEffect","detail":"Without abort, switching pages quickly causes race conditions — the previous fetch response overwrites the new one. AbortController cancels pending requests on cleanup.","category":"Performance"},"as-const":{"tip":"Use 'as const' to infer literal types instead of generic string","detail":"const roles = ['admin', 'user'] as const infers type readonly ['admin', 'user'] instead of string[]. Allows extracting union types: type Role = typeof roles[number]","category":"TypeScript"},"error-boundary":{"tip":"Always wrap routes and independent sections with Error Boundaries","detail":"An error in a child component crashes the entire React tree. Error Boundaries isolate crashes — the sidebar can break without bringing down the whole page.","category":"React"},"barrel-files":{"tip":"Avoid barrel files (index.ts) in large projects — they kill tree-shaking","detail":"Importing from index.ts forces the bundler to evaluate all re-exports. In monorepos, this can add hundreds of KB to the bundle. Import directly from the source file.","category":"Architecture"},"server-components":{"tip":"Components that only display data should be Server Components — don't add 'use client' unnecessarily","detail":"Server Components run on the server = zero JavaScript in the client bundle. Only add 'use client' when you need hooks, event handlers, or browser APIs.","category":"Next.js"},"composition-over-config":{"tip":"Prefer composition over configuration in public components","detail":"Instead of <Card showHeader showFooter headerTitle='...' footerAction='...'>, use <Card><CardHeader>...</CardHeader><CardFooter>...</CardFooter></Card>. More flexible, typed, and extensible.","category":"Patterns"},"use-sync-external-store":{"tip":"Use useSyncExternalStore to integrate external stores with React 18+","detail":"It's the official hook for syncing React with any external data source (localStorage, WebSocket, Redux-like stores). Ensures consistency with concurrent rendering.","category":"React"}}}
