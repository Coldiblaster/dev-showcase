{
  "hero": {
    "badge": "Guia Prático",
    "title": "React Design Patterns",
    "subtitle": "// arquitetura, composição e boas práticas",
    "description": "Patterns arquiteturais de React usados em projetos profissionais: Compound Components, Custom Hooks, Render Props, HOCs e mais — com exemplos práticos."
  },
  "sectionNav": {
    "composition": "Composição",
    "hooks": "Custom Hooks",
    "statePatterns": "Estado",
    "performance": "Performance"
  },
  "composition": {
    "title": "Composição & Componentes",
    "subtitle": "// patterns para componentes flexíveis",
    "description": "Patterns que tornam seus componentes mais flexíveis, reutilizáveis e fáceis de manter.",
    "items": [
      {
        "name": "Compound Components",
        "description": "Componentes que trabalham juntos compartilhando estado implícito via Context. Permite API declarativa e flexível.",
        "code": "// API declarativa e limpa\n<Select>\n  <Select.Trigger>Escolha uma opção</Select.Trigger>\n  <Select.Content>\n    <Select.Item value=\"react\">React</Select.Item>\n    <Select.Item value=\"vue\">Vue</Select.Item>\n    <Select.Item value=\"angular\">Angular</Select.Item>\n  </Select.Content>\n</Select>\n\n// Implementação com Context\nconst SelectContext = createContext<SelectState | null>(null);\n\nfunction Select({ children }: { children: ReactNode }) {\n  const [value, setValue] = useState('');\n  return (\n    <SelectContext.Provider value={{ value, setValue }}>\n      {children}\n    </SelectContext.Provider>\n  );\n}\n\nSelect.Trigger = function Trigger({ children }) { /* ... */ };\nSelect.Content = function Content({ children }) { /* ... */ };\nSelect.Item = function Item({ value, children }) { /* ... */ };",
        "useCases": ["Selects, Tabs, Accordions", "Menus e Dropdowns", "Form Fields compostos"]
      },
      {
        "name": "Render Props",
        "description": "Passa uma função como prop (ou children) que recebe dados e retorna JSX. Útil para injetar lógica sem impor UI.",
        "code": "// O componente fornece dados, o consumidor decide a UI\nfunction MouseTracker({ children }: {\n  children: (pos: { x: number; y: number }) => ReactNode\n}) {\n  const [pos, setPos] = useState({ x: 0, y: 0 });\n\n  useEffect(() => {\n    const handler = (e: MouseEvent) =>\n      setPos({ x: e.clientX, y: e.clientY });\n    window.addEventListener('mousemove', handler);\n    return () => window.removeEventListener('mousemove', handler);\n  }, []);\n\n  return <>{children(pos)}</>;\n}\n\n// Uso\n<MouseTracker>\n  {({ x, y }) => (\n    <div>Mouse: {x}, {y}</div>\n  )}\n</MouseTracker>",
        "useCases": ["Injeção de dados sem impor layout", "Componentes headless", "Libs de formulário"]
      },
      {
        "name": "Container / Presentational",
        "description": "Separe lógica (Container) de apresentação (Presentational). O Container busca dados e gerencia estado, o Presentational só renderiza.",
        "code": "// Container — lógica e dados\nfunction UserListContainer() {\n  const { data, isLoading } = useQuery({\n    queryKey: ['users'],\n    queryFn: fetchUsers\n  });\n\n  if (isLoading) return <Skeleton />;\n  return <UserList users={data ?? []} />;\n}\n\n// Presentational — só UI, sem lógica\nfunction UserList({ users }: { users: User[] }) {\n  return (\n    <ul>\n      {users.map(user => (\n        <li key={user.id}>{user.name}</li>\n      ))}\n    </ul>\n  );\n}",
        "useCases": ["Separação de responsabilidades", "Componentes testáveis", "Reuso da camada visual"]
      }
    ],
    "useCasesLabel": "Quando usar"
  },
  "hooks": {
    "title": "Custom Hooks",
    "subtitle": "// extraia e reutilize lógica",
    "description": "Custom hooks encapsulam lógica reutilizável. São a forma mais idiomática de compartilhar comportamento entre componentes no React.",
    "items": [
      {
        "name": "useLocalStorage",
        "description": "Persiste estado no localStorage com sincronização automática.",
        "code": "function useLocalStorage<T>(key: string, initial: T) {\n  const [value, setValue] = useState<T>(() => {\n    if (typeof window === 'undefined') return initial;\n    const stored = localStorage.getItem(key);\n    return stored ? JSON.parse(stored) : initial;\n  });\n\n  useEffect(() => {\n    localStorage.setItem(key, JSON.stringify(value));\n  }, [key, value]);\n\n  return [value, setValue] as const;\n}\n\n// Uso\nconst [theme, setTheme] = useLocalStorage('theme', 'dark');"
      },
      {
        "name": "useDebounce",
        "description": "Atrasa a atualização de um valor — ideal para buscas e inputs.",
        "code": "function useDebounce<T>(value: T, delay: number): T {\n  const [debounced, setDebounced] = useState(value);\n\n  useEffect(() => {\n    const timer = setTimeout(() => setDebounced(value), delay);\n    return () => clearTimeout(timer);\n  }, [value, delay]);\n\n  return debounced;\n}\n\n// Uso\nconst [search, setSearch] = useState('');\nconst debouncedSearch = useDebounce(search, 300);\n\nuseEffect(() => {\n  fetchResults(debouncedSearch);\n}, [debouncedSearch]);"
      },
      {
        "name": "useMediaQuery",
        "description": "Reage a mudanças de media query (responsividade) no JavaScript.",
        "code": "function useMediaQuery(query: string): boolean {\n  const [matches, setMatches] = useState(false);\n\n  useEffect(() => {\n    const media = window.matchMedia(query);\n    setMatches(media.matches);\n\n    const listener = (e: MediaQueryListEvent) =>\n      setMatches(e.matches);\n    media.addEventListener('change', listener);\n    return () => media.removeEventListener('change', listener);\n  }, [query]);\n\n  return matches;\n}\n\n// Uso\nconst isMobile = useMediaQuery('(max-width: 768px)');"
      },
      {
        "name": "useClickOutside",
        "description": "Detecta cliques fora de um elemento — perfeito para modais e dropdowns.",
        "code": "function useClickOutside(\n  ref: RefObject<HTMLElement | null>,\n  handler: () => void\n) {\n  useEffect(() => {\n    const listener = (e: MouseEvent | TouchEvent) => {\n      if (!ref.current?.contains(e.target as Node)) {\n        handler();\n      }\n    };\n    document.addEventListener('mousedown', listener);\n    document.addEventListener('touchstart', listener);\n    return () => {\n      document.removeEventListener('mousedown', listener);\n      document.removeEventListener('touchstart', listener);\n    };\n  }, [ref, handler]);\n}\n\n// Uso\nconst ref = useRef<HTMLDivElement>(null);\nuseClickOutside(ref, () => setOpen(false));"
      }
    ]
  },
  "statePatterns": {
    "title": "Patterns de Estado",
    "subtitle": "// gerencie estado de forma escalável",
    "description": "Patterns para gerenciar estado complexo de forma organizada e previsível.",
    "items": [
      {
        "name": "Reducer Pattern",
        "description": "Use useReducer para estado complexo com múltiplas ações. Mais previsível que múltiplos useState.",
        "before": "// Múltiplos useState — difícil de manter\nconst [items, setItems] = useState([]);\nconst [loading, setLoading] = useState(false);\nconst [error, setError] = useState(null);\nconst [page, setPage] = useState(1);\n\n// Atualização espalhada pelo componente\nsetLoading(true);\nsetError(null);\nfetch(url)\n  .then(data => { setItems(data); setLoading(false); })\n  .catch(err => { setError(err); setLoading(false); });",
        "after": "type Action =\n  | { type: 'FETCH_START' }\n  | { type: 'FETCH_SUCCESS'; payload: Item[] }\n  | { type: 'FETCH_ERROR'; error: string }\n  | { type: 'NEXT_PAGE' };\n\nfunction reducer(state: State, action: Action): State {\n  switch (action.type) {\n    case 'FETCH_START':\n      return { ...state, loading: true, error: null };\n    case 'FETCH_SUCCESS':\n      return { ...state, items: action.payload, loading: false };\n    case 'FETCH_ERROR':\n      return { ...state, error: action.error, loading: false };\n    case 'NEXT_PAGE':\n      return { ...state, page: state.page + 1 };\n  }\n}\n\nconst [state, dispatch] = useReducer(reducer, initialState);"
      },
      {
        "name": "Context + Provider Pattern",
        "description": "Compartilhe estado global com tipo seguro via Context. Evita prop drilling em árvores profundas.",
        "before": "// Prop drilling — 4 níveis de profundidade\n<App user={user} />\n  <Layout user={user} />\n    <Sidebar user={user} />\n      <UserMenu user={user} />\n        <Avatar name={user.name} />",
        "after": "// Context elimina prop drilling\nconst UserContext = createContext<User | null>(null);\n\nfunction useUser() {\n  const user = useContext(UserContext);\n  if (!user) throw new Error('useUser must be within Provider');\n  return user;\n}\n\nfunction UserProvider({ children }: { children: ReactNode }) {\n  const [user, setUser] = useState<User | null>(null);\n  return (\n    <UserContext.Provider value={user}>\n      {children}\n    </UserContext.Provider>\n  );\n}\n\n// Qualquer nível acessa direto\nfunction Avatar() {\n  const user = useUser();\n  return <img src={user.avatar} />;\n}"
      }
    ],
    "before": "Antes",
    "after": "Depois",
    "withPattern": "✅ com pattern",
    "withoutPattern": "❌ sem pattern"
  },
  "performance": {
    "title": "Performance Patterns",
    "subtitle": "// otimize renders e carregamento",
    "description": "Técnicas para evitar re-renders desnecessários e otimizar carregamento.",
    "items": [
      {
        "name": "React.memo + useCallback",
        "description": "Evite re-renders de componentes filhos quando props não mudam.",
        "code": "// Componente memoizado — só re-renderiza se props mudarem\nconst ExpensiveList = memo(function ExpensiveList({\n  items,\n  onItemClick,\n}: {\n  items: Item[];\n  onItemClick: (id: string) => void;\n}) {\n  return (\n    <ul>\n      {items.map(item => (\n        <li key={item.id} onClick={() => onItemClick(item.id)}>\n          {item.name}\n        </li>\n      ))}\n    </ul>\n  );\n});\n\n// Parent estabiliza a referência da função\nfunction Parent() {\n  const [items] = useState(fetchItems());\n\n  const handleClick = useCallback((id: string) => {\n    console.log('clicked', id);\n  }, []);\n\n  return <ExpensiveList items={items} onItemClick={handleClick} />;\n}"
      },
      {
        "name": "useMemo para Cálculos Pesados",
        "description": "Memorize resultados de cálculos caros para evitar recomputação a cada render.",
        "code": "function Dashboard({ transactions }: { transactions: Transaction[] }) {\n  // Só recalcula quando transactions muda\n  const stats = useMemo(() => ({\n    total: transactions.reduce((sum, t) => sum + t.amount, 0),\n    average: transactions.reduce((sum, t) => sum + t.amount, 0)\n      / transactions.length,\n    max: Math.max(...transactions.map(t => t.amount)),\n    byCategory: groupBy(transactions, 'category'),\n  }), [transactions]);\n\n  return (\n    <div>\n      <StatCard label=\"Total\" value={stats.total} />\n      <StatCard label=\"Média\" value={stats.average} />\n    </div>\n  );\n}"
      },
      {
        "name": "Lazy Loading + Suspense",
        "description": "Carregue componentes pesados sob demanda para reduzir o bundle inicial.",
        "code": "import { lazy, Suspense } from 'react';\n\n// Carregado apenas quando necessário\nconst HeavyChart = lazy(() => import('./HeavyChart'));\nconst MarkdownEditor = lazy(() => import('./MarkdownEditor'));\n\nfunction App() {\n  const [showChart, setShowChart] = useState(false);\n\n  return (\n    <div>\n      <button onClick={() => setShowChart(true)}>\n        Mostrar Gráfico\n      </button>\n\n      {showChart && (\n        <Suspense fallback={<Skeleton className=\"h-64\" />}>\n          <HeavyChart data={data} />\n        </Suspense>\n      )}\n    </div>\n  );\n}"
      }
    ]
  },
  "cta": {
    "title": "Pronto para React avançado?",
    "description": "Explore mais guias e ferramentas práticas para devs.",
    "button": "Voltar às Dicas"
  }
}
