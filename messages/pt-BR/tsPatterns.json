{
  "hero": {
    "badge": "Guia Prático",
    "title": "TypeScript Patterns",
    "subtitle": "// tipos avançados, generics e boas práticas",
    "description": "Referência prática com exemplos interativos de Utility Types, Generics, Type Narrowing e patterns avançados para escrever TypeScript mais seguro e expressivo."
  },
  "sectionNav": {
    "utilityTypes": "Utility Types",
    "narrowing": "Narrowing",
    "advanced": "Avançado"
  },
  "utilityTypes": {
    "title": "Utility Types",
    "subtitle": "// tipos built-in que todo dev precisa conhecer",
    "description": "TypeScript oferece vários types utilitários globais que facilitam transformações de tipos comuns.",
    "items": [
      {
        "name": "Partial<T>",
        "description": "Torna todas as propriedades opcionais. Útil para funções de update parcial.",
        "code": "interface User {\n  name: string;\n  email: string;\n  age: number;\n}\n\nfunction updateUser(user: User, fields: Partial<User>) {\n  return { ...user, ...fields };\n}\n\n// ✅ Só precisa passar o que quer atualizar\nupdateUser(user, { name: 'Novo Nome' });",
        "highlight": "Partial<User>"
      },
      {
        "name": "Required<T>",
        "description": "O oposto de Partial — torna todas as propriedades obrigatórias.",
        "code": "interface Config {\n  host?: string;\n  port?: number;\n  debug?: boolean;\n}\n\nfunction startServer(config: Required<Config>) {\n  // Garantia que todos os campos existem\n  console.log(`${config.host}:${config.port}`);\n}",
        "highlight": "Required<Config>"
      },
      {
        "name": "Pick<T, K>",
        "description": "Seleciona apenas propriedades específicas de um tipo.",
        "code": "interface Article {\n  id: string;\n  title: string;\n  body: string;\n  author: string;\n  createdAt: Date;\n}\n\n// Só precisa de title e body para o form\ntype ArticleForm = Pick<Article, 'title' | 'body'>;",
        "highlight": "Pick<Article, 'title' | 'body'>"
      },
      {
        "name": "Omit<T, K>",
        "description": "Remove propriedades específicas de um tipo.",
        "code": "interface User {\n  id: string;\n  name: string;\n  email: string;\n  password: string;\n}\n\n// Remove senha para respostas da API\ntype PublicUser = Omit<User, 'password'>;",
        "highlight": "Omit<User, 'password'>"
      },
      {
        "name": "Record<K, T>",
        "description": "Cria um tipo de objeto com chaves K e valores T.",
        "code": "type Status = 'idle' | 'loading' | 'success' | 'error';\n\nconst statusMessages: Record<Status, string> = {\n  idle: 'Aguardando...',\n  loading: 'Carregando...',\n  success: 'Concluído!',\n  error: 'Erro ao processar',\n};",
        "highlight": "Record<Status, string>"
      },
      {
        "name": "Extract / Exclude",
        "description": "Extract mantém tipos atribuíveis, Exclude remove.",
        "code": "type Event = 'click' | 'scroll' | 'mousemove' | 'keypress';\n\n// Apenas eventos de mouse\ntype MouseEvent = Extract<Event, 'click' | 'mousemove'>;\n// → 'click' | 'mousemove'\n\n// Tudo exceto teclado\ntype NonKeyEvent = Exclude<Event, 'keypress'>;\n// → 'click' | 'scroll' | 'mousemove'",
        "highlight": "Extract / Exclude"
      }
    ]
  },
  "generics": {
    "title": "Generics",
    "subtitle": "// tipos reutilizáveis e type-safe",
    "description": "Generics permitem criar componentes, funções e tipos que funcionam com qualquer tipo, mantendo type safety.",
    "items": [
      {
        "name": "Função Genérica",
        "description": "O tipo é inferido automaticamente a partir dos argumentos.",
        "code": "function firstElement<T>(arr: T[]): T | undefined {\n  return arr[0];\n}\n\n// TypeScript infere o tipo de retorno\nconst num = firstElement([1, 2, 3]);      // number\nconst str = firstElement(['a', 'b']);      // string",
        "tag": "Básico"
      },
      {
        "name": "Constraints (extends)",
        "description": "Restrinja o tipo genérico para garantir que tenha certas propriedades.",
        "code": "interface HasLength {\n  length: number;\n}\n\nfunction logLength<T extends HasLength>(item: T): T {\n  console.log(item.length);\n  return item;\n}\n\nlogLength('hello');     // ✅ string tem length\nlogLength([1, 2, 3]);   // ✅ array tem length\n// logLength(123);      // ❌ number não tem length",
        "tag": "Constraints"
      },
      {
        "name": "keyof + Generics",
        "description": "Combine keyof com generics para acessar propriedades de forma type-safe.",
        "code": "function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {\n  return obj[key];\n}\n\nconst user = { name: 'Ana', age: 28 };\n\nconst name = getProperty(user, 'name'); // string\nconst age = getProperty(user, 'age');   // number\n// getProperty(user, 'email');           // ❌ Erro!",
        "tag": "Avançado"
      },
      {
        "name": "Generic com Default",
        "description": "Defina um tipo padrão para quando o genérico não for especificado.",
        "code": "interface ApiResponse<T = unknown> {\n  data: T;\n  status: number;\n  message: string;\n}\n\n// Com tipo específico\nconst userRes: ApiResponse<User> = { ... };\n\n// Sem especificar (usa unknown)\nconst genericRes: ApiResponse = { ... };",
        "tag": "Patterns"
      },
      {
        "name": "Mapped Types + Generics",
        "description": "Crie novos tipos transformando propriedades de tipos existentes.",
        "code": "type Getters<T> = {\n  [K in keyof T as `get${Capitalize<string & K>}`]: () => T[K];\n};\n\ninterface Person {\n  name: string;\n  age: number;\n}\n\ntype PersonGetters = Getters<Person>;\n// { getName: () => string; getAge: () => number; }",
        "tag": "Avançado"
      }
    ]
  },
  "narrowing": {
    "title": "Type Narrowing",
    "subtitle": "// refinando tipos em runtime",
    "description": "Type Narrowing é o processo de refinar tipos de um tipo mais amplo para um mais específico usando verificações em runtime.",
    "before": "Antes",
    "after": "Depois",
    "withNarrowing": "✅ com narrowing",
    "withoutNarrowing": "❌ sem narrowing",
    "items": [
      {
        "name": "typeof guard",
        "description": "O guard mais básico — verifica tipos primitivos.",
        "before": "function process(value: string | number) {\n  // value é string | number\n  console.log(value.toUpperCase());\n  // ❌ Erro: toUpperCase não existe em number\n}",
        "after": "function process(value: string | number) {\n  if (typeof value === 'string') {\n    console.log(value.toUpperCase()); // ✅ string\n  } else {\n    console.log(value.toFixed(2));    // ✅ number\n  }\n}"
      },
      {
        "name": "Discriminated Unions",
        "description": "Pattern poderoso usando uma propriedade literal para distinguir tipos.",
        "before": "interface Shape {\n  kind: string;\n  radius?: number;\n  width?: number;\n  height?: number;\n}\n\n// Propriedades opcionais geram incerteza\nfunction area(shape: Shape) {\n  if (shape.kind === 'circle') {\n    return Math.PI * shape.radius! ** 2; // ! é perigoso\n  }\n}",
        "after": "interface Circle  { kind: 'circle';  radius: number }\ninterface Square  { kind: 'square';  side: number }\ninterface Rect    { kind: 'rect';    w: number; h: number }\n\ntype Shape = Circle | Square | Rect;\n\nfunction area(shape: Shape): number {\n  switch (shape.kind) {\n    case 'circle': return Math.PI * shape.radius ** 2;\n    case 'square': return shape.side ** 2;\n    case 'rect':   return shape.w * shape.h;\n  }\n}"
      },
      {
        "name": "Type Predicates (is)",
        "description": "Crie suas próprias funções de type guard customizadas.",
        "before": "interface Fish { swim: () => void }\ninterface Bird { fly: () => void }\n\n// Sem type predicate, TS não sabe qual tipo é\nfunction move(animal: Fish | Bird) {\n  if ('swim' in animal) {\n    animal.swim(); // funciona, mas não é ideal\n  }\n}",
        "after": "function isFish(pet: Fish | Bird): pet is Fish {\n  return 'swim' in pet;\n}\n\nfunction move(animal: Fish | Bird) {\n  if (isFish(animal)) {\n    animal.swim(); // ✅ TypeScript sabe que é Fish\n  } else {\n    animal.fly();  // ✅ TypeScript sabe que é Bird\n  }\n}"
      },
      {
        "name": "Exhaustive Check (never)",
        "description": "Garanta que todos os casos de uma union foram tratados em compile time.",
        "before": "type Status = 'active' | 'inactive' | 'banned';\n\nfunction getLabel(status: Status) {\n  switch (status) {\n    case 'active': return 'Ativo';\n    case 'inactive': return 'Inativo';\n    // Esqueceu 'banned' — sem erro!\n  }\n}",
        "after": "function getLabel(status: Status): string {\n  switch (status) {\n    case 'active':   return 'Ativo';\n    case 'inactive': return 'Inativo';\n    case 'banned':   return 'Banido';\n    default: {\n      const _exhaustive: never = status;\n      return _exhaustive; // ❌ Erro se faltar caso\n    }\n  }\n}"
      }
    ]
  },
  "advanced": {
    "title": "Patterns Avançados",
    "subtitle": "// técnicas para projetos reais",
    "description": "Patterns e técnicas avançadas de TypeScript usados em projetos profissionais.",
    "items": [
      {
        "name": "Template Literal Types",
        "description": "Combine string literals para criar tipos derivados automaticamente.",
        "code": "type EventName = 'click' | 'focus' | 'blur';\ntype Handler = `on${Capitalize<EventName>}`;\n// 'onClick' | 'onFocus' | 'onBlur'\n\ntype CSSProperty = 'margin' | 'padding';\ntype Direction = 'Top' | 'Right' | 'Bottom' | 'Left';\ntype CSSKey = `${CSSProperty}${Direction}`;\n// 'marginTop' | 'marginRight' | ... 8 combinações"
      },
      {
        "name": "Conditional Types",
        "description": "Tipos que se comportam como if/else baseado em condições.",
        "code": "type IsString<T> = T extends string ? true : false;\n\ntype A = IsString<'hello'>; // true\ntype B = IsString<42>;      // false\n\n// Exemplo prático: extrair tipo de retorno de Promise\ntype UnwrapPromise<T> = T extends Promise<infer U> ? U : T;\n\ntype Result = UnwrapPromise<Promise<string>>; // string\ntype Plain = UnwrapPromise<number>;           // number"
      },
      {
        "name": "Infer Keyword",
        "description": "Extraia tipos de dentro de outros tipos usando infer.",
        "code": "// Extrair tipo dos elementos de um array\ntype ElementOf<T> = T extends (infer E)[] ? E : never;\ntype Num = ElementOf<number[]>; // number\n\n// Extrair tipo dos parâmetros de uma função\ntype FirstParam<F> = F extends (arg: infer P, ...args: unknown[]) => unknown\n  ? P\n  : never;\n\ntype Param = FirstParam<(name: string, age: number) => void>;\n// string"
      },
      {
        "name": "Builder Pattern Type-Safe",
        "description": "Use generics para criar APIs fluentes com tipos que evoluem.",
        "code": "class QueryBuilder<T extends object = object> {\n  private filters: Partial<T> = {};\n\n  where<K extends keyof T>(key: K, value: T[K]) {\n    this.filters[key] = value;\n    return this;\n  }\n\n  build() {\n    return this.filters;\n  }\n}\n\n// Uso type-safe\nnew QueryBuilder<User>()\n  .where('name', 'Ana')   // ✅\n  .where('age', 28)        // ✅\n  // .where('age', 'abc')  // ❌ Erro!\n  .build();"
      },
      {
        "name": "Branded Types",
        "description": "Crie tipos nominais para evitar misturar valores que são estruturalmente iguais.",
        "code": "type Brand<T, B> = T & { __brand: B };\n\ntype UserId = Brand<string, 'UserId'>;\ntype OrderId = Brand<string, 'OrderId'>;\n\nfunction getUser(id: UserId) { /* ... */ }\nfunction getOrder(id: OrderId) { /* ... */ }\n\nconst userId = 'u_123' as UserId;\nconst orderId = 'o_456' as OrderId;\n\ngetUser(userId);    // ✅\n// getUser(orderId); // ❌ Tipo incompatível!"
      }
    ]
  },
  "cta": {
    "title": "Pronto para TypeScript avançado?",
    "description": "Explore mais guias e ferramentas práticas para devs.",
    "button": "Voltar às Dicas"
  }
}
