{
  "hero": {
    "badge": "Guía Práctica",
    "title": "React Design Patterns",
    "subtitle": "// arquitectura, composición y buenas prácticas",
    "description": "Patrones arquitectónicos de React usados en proyectos profesionales: Compound Components, Custom Hooks, Render Props, HOCs y más — con ejemplos prácticos."
  },
  "sectionNav": {
    "composition": "Composición",
    "hooks": "Custom Hooks",
    "statePatterns": "Estado",
    "performance": "Performance"
  },
  "composition": {
    "title": "Composición & Componentes",
    "subtitle": "// patrones para componentes flexibles",
    "description": "Patrones que hacen tus componentes más flexibles, reutilizables y fáciles de mantener.",
    "items": [
      {
        "name": "Compound Components",
        "description": "Componentes que trabajan juntos compartiendo estado implícito vía Context. Permite API declarativa y flexible.",
        "code": "// API declarativa y limpia\n<Select>\n  <Select.Trigger>Elige una opción</Select.Trigger>\n  <Select.Content>\n    <Select.Item value=\"react\">React</Select.Item>\n    <Select.Item value=\"vue\">Vue</Select.Item>\n    <Select.Item value=\"angular\">Angular</Select.Item>\n  </Select.Content>\n</Select>\n\n// Implementación con Context\nconst SelectContext = createContext<SelectState | null>(null);\n\nfunction Select({ children }: { children: ReactNode }) {\n  const [value, setValue] = useState('');\n  return (\n    <SelectContext.Provider value={{ value, setValue }}>\n      {children}\n    </SelectContext.Provider>\n  );\n}\n\nSelect.Trigger = function Trigger({ children }) { /* ... */ };\nSelect.Content = function Content({ children }) { /* ... */ };\nSelect.Item = function Item({ value, children }) { /* ... */ };",
        "useCases": ["Selects, Tabs, Accordions", "Menús y Dropdowns", "Form Fields compuestos"]
      },
      {
        "name": "Render Props",
        "description": "Pasa una función como prop (o children) que recibe datos y retorna JSX. Útil para inyectar lógica sin imponer UI.",
        "code": "// El componente proporciona datos, el consumidor decide la UI\nfunction MouseTracker({ children }: {\n  children: (pos: { x: number; y: number }) => ReactNode\n}) {\n  const [pos, setPos] = useState({ x: 0, y: 0 });\n\n  useEffect(() => {\n    const handler = (e: MouseEvent) =>\n      setPos({ x: e.clientX, y: e.clientY });\n    window.addEventListener('mousemove', handler);\n    return () => window.removeEventListener('mousemove', handler);\n  }, []);\n\n  return <>{children(pos)}</>;\n}\n\n// Uso\n<MouseTracker>\n  {({ x, y }) => (\n    <div>Mouse: {x}, {y}</div>\n  )}\n</MouseTracker>",
        "useCases": ["Inyección de datos sin imponer layout", "Componentes headless", "Librerías de formularios"]
      },
      {
        "name": "Container / Presentational",
        "description": "Separa lógica (Container) de presentación (Presentational). El Container obtiene datos y gestiona estado, el Presentational solo renderiza.",
        "code": "// Container — lógica y datos\nfunction UserListContainer() {\n  const { data, isLoading } = useQuery({\n    queryKey: ['users'],\n    queryFn: fetchUsers\n  });\n\n  if (isLoading) return <Skeleton />;\n  return <UserList users={data ?? []} />;\n}\n\n// Presentational — solo UI, sin lógica\nfunction UserList({ users }: { users: User[] }) {\n  return (\n    <ul>\n      {users.map(user => (\n        <li key={user.id}>{user.name}</li>\n      ))}\n    </ul>\n  );\n}",
        "useCases": ["Separación de responsabilidades", "Componentes testeables", "Reutilización de la capa visual"]
      }
    ],
    "useCasesLabel": "Cuándo usar"
  },
  "hooks": {
    "title": "Custom Hooks",
    "subtitle": "// extrae y reutiliza lógica",
    "description": "Los custom hooks encapsulan lógica reutilizable. Son la forma más idiomática de compartir comportamiento entre componentes en React.",
    "items": [
      {
        "name": "useLocalStorage",
        "description": "Persiste estado en localStorage con sincronización automática.",
        "code": "function useLocalStorage<T>(key: string, initial: T) {\n  const [value, setValue] = useState<T>(() => {\n    if (typeof window === 'undefined') return initial;\n    const stored = localStorage.getItem(key);\n    return stored ? JSON.parse(stored) : initial;\n  });\n\n  useEffect(() => {\n    localStorage.setItem(key, JSON.stringify(value));\n  }, [key, value]);\n\n  return [value, setValue] as const;\n}\n\n// Uso\nconst [theme, setTheme] = useLocalStorage('theme', 'dark');"
      },
      {
        "name": "useDebounce",
        "description": "Retrasa la actualización de un valor — ideal para búsquedas e inputs.",
        "code": "function useDebounce<T>(value: T, delay: number): T {\n  const [debounced, setDebounced] = useState(value);\n\n  useEffect(() => {\n    const timer = setTimeout(() => setDebounced(value), delay);\n    return () => clearTimeout(timer);\n  }, [value, delay]);\n\n  return debounced;\n}\n\n// Uso\nconst [search, setSearch] = useState('');\nconst debouncedSearch = useDebounce(search, 300);\n\nuseEffect(() => {\n  fetchResults(debouncedSearch);\n}, [debouncedSearch]);"
      },
      {
        "name": "useMediaQuery",
        "description": "Reacciona a cambios de media query (responsividad) en JavaScript.",
        "code": "function useMediaQuery(query: string): boolean {\n  const [matches, setMatches] = useState(false);\n\n  useEffect(() => {\n    const media = window.matchMedia(query);\n    setMatches(media.matches);\n\n    const listener = (e: MediaQueryListEvent) =>\n      setMatches(e.matches);\n    media.addEventListener('change', listener);\n    return () => media.removeEventListener('change', listener);\n  }, [query]);\n\n  return matches;\n}\n\n// Uso\nconst isMobile = useMediaQuery('(max-width: 768px)');"
      },
      {
        "name": "useClickOutside",
        "description": "Detecta clics fuera de un elemento — perfecto para modales y dropdowns.",
        "code": "function useClickOutside(\n  ref: RefObject<HTMLElement | null>,\n  handler: () => void\n) {\n  useEffect(() => {\n    const listener = (e: MouseEvent | TouchEvent) => {\n      if (!ref.current?.contains(e.target as Node)) {\n        handler();\n      }\n    };\n    document.addEventListener('mousedown', listener);\n    document.addEventListener('touchstart', listener);\n    return () => {\n      document.removeEventListener('mousedown', listener);\n      document.removeEventListener('touchstart', listener);\n    };\n  }, [ref, handler]);\n}\n\n// Uso\nconst ref = useRef<HTMLDivElement>(null);\nuseClickOutside(ref, () => setOpen(false));"
      }
    ]
  },
  "statePatterns": {
    "title": "Patrones de Estado",
    "subtitle": "// gestiona estado de forma escalable",
    "description": "Patrones para gestionar estado complejo de forma organizada y predecible.",
    "items": [
      {
        "name": "Reducer Pattern",
        "description": "Usa useReducer para estado complejo con múltiples acciones. Más predecible que múltiples useState.",
        "before": "// Múltiples useState — difícil de mantener\nconst [items, setItems] = useState([]);\nconst [loading, setLoading] = useState(false);\nconst [error, setError] = useState(null);\nconst [page, setPage] = useState(1);\n\n// Actualizaciones dispersas por el componente\nsetLoading(true);\nsetError(null);\nfetch(url)\n  .then(data => { setItems(data); setLoading(false); })\n  .catch(err => { setError(err); setLoading(false); });",
        "after": "type Action =\n  | { type: 'FETCH_START' }\n  | { type: 'FETCH_SUCCESS'; payload: Item[] }\n  | { type: 'FETCH_ERROR'; error: string }\n  | { type: 'NEXT_PAGE' };\n\nfunction reducer(state: State, action: Action): State {\n  switch (action.type) {\n    case 'FETCH_START':\n      return { ...state, loading: true, error: null };\n    case 'FETCH_SUCCESS':\n      return { ...state, items: action.payload, loading: false };\n    case 'FETCH_ERROR':\n      return { ...state, error: action.error, loading: false };\n    case 'NEXT_PAGE':\n      return { ...state, page: state.page + 1 };\n  }\n}\n\nconst [state, dispatch] = useReducer(reducer, initialState);"
      },
      {
        "name": "Context + Provider Pattern",
        "description": "Comparte estado global con tipado seguro vía Context. Evita prop drilling en árboles profundos.",
        "before": "// Prop drilling — 4 niveles de profundidad\n<App user={user} />\n  <Layout user={user} />\n    <Sidebar user={user} />\n      <UserMenu user={user} />\n        <Avatar name={user.name} />",
        "after": "// Context elimina prop drilling\nconst UserContext = createContext<User | null>(null);\n\nfunction useUser() {\n  const user = useContext(UserContext);\n  if (!user) throw new Error('useUser must be within Provider');\n  return user;\n}\n\nfunction UserProvider({ children }: { children: ReactNode }) {\n  const [user, setUser] = useState<User | null>(null);\n  return (\n    <UserContext.Provider value={user}>\n      {children}\n    </UserContext.Provider>\n  );\n}\n\n// Cualquier nivel accede directamente\nfunction Avatar() {\n  const user = useUser();\n  return <img src={user.avatar} />;\n}"
      }
    ],
    "before": "Antes",
    "after": "Después",
    "withPattern": "✅ con patrón",
    "withoutPattern": "❌ sin patrón"
  },
  "performance": {
    "title": "Patrones de Performance",
    "subtitle": "// optimiza renders y carga",
    "description": "Técnicas para evitar re-renders innecesarios y optimizar la carga.",
    "items": [
      {
        "name": "React.memo + useCallback",
        "description": "Evita re-renders de componentes hijos cuando las props no cambian.",
        "code": "// Componente memoizado — solo re-renderiza si las props cambian\nconst ExpensiveList = memo(function ExpensiveList({\n  items,\n  onItemClick,\n}: {\n  items: Item[];\n  onItemClick: (id: string) => void;\n}) {\n  return (\n    <ul>\n      {items.map(item => (\n        <li key={item.id} onClick={() => onItemClick(item.id)}>\n          {item.name}\n        </li>\n      ))}\n    </ul>\n  );\n});\n\n// Parent estabiliza la referencia de la función\nfunction Parent() {\n  const [items] = useState(fetchItems());\n\n  const handleClick = useCallback((id: string) => {\n    console.log('clicked', id);\n  }, []);\n\n  return <ExpensiveList items={items} onItemClick={handleClick} />;\n}"
      },
      {
        "name": "useMemo para Cálculos Pesados",
        "description": "Memoriza resultados de cálculos costosos para evitar recomputación en cada render.",
        "code": "function Dashboard({ transactions }: { transactions: Transaction[] }) {\n  // Solo recalcula cuando transactions cambia\n  const stats = useMemo(() => ({\n    total: transactions.reduce((sum, t) => sum + t.amount, 0),\n    average: transactions.reduce((sum, t) => sum + t.amount, 0)\n      / transactions.length,\n    max: Math.max(...transactions.map(t => t.amount)),\n    byCategory: groupBy(transactions, 'category'),\n  }), [transactions]);\n\n  return (\n    <div>\n      <StatCard label=\"Total\" value={stats.total} />\n      <StatCard label=\"Media\" value={stats.average} />\n    </div>\n  );\n}"
      },
      {
        "name": "Lazy Loading + Suspense",
        "description": "Carga componentes pesados bajo demanda para reducir el bundle inicial.",
        "code": "import { lazy, Suspense } from 'react';\n\n// Cargado solo cuando es necesario\nconst HeavyChart = lazy(() => import('./HeavyChart'));\nconst MarkdownEditor = lazy(() => import('./MarkdownEditor'));\n\nfunction App() {\n  const [showChart, setShowChart] = useState(false);\n\n  return (\n    <div>\n      <button onClick={() => setShowChart(true)}>\n        Mostrar Gráfico\n      </button>\n\n      {showChart && (\n        <Suspense fallback={<Skeleton className=\"h-64\" />}>\n          <HeavyChart data={data} />\n        </Suspense>\n      )}\n    </div>\n  );\n}"
      }
    ]
  },
  "cta": {
    "title": "¿Listo para React avanzado?",
    "description": "Explora más guías y herramientas prácticas para devs.",
    "button": "Volver a Consejos"
  }
}
