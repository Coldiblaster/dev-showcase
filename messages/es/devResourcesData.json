{"snippets":{"debounce":{"title":"useDebounce Hook","description":"Retrasa la actualización de un valor hasta que el usuario deje de escribir","explanation":"**useDebounce** retrasa la actualización de un valor hasta que el usuario deje de escribir.\n\n**Cómo funciona:**\n• Recibe el valor y el delay en ms\n• Usa setTimeout para retrasar la actualización\n• Limpia el timer anterior en cada cambio (cleanup del useEffect)\n• Devuelve el valor \"debounced\" — solo se actualiza tras el delay\n\n**Cuándo usar:**\n• Campos de búsqueda (evita peticiones en cada tecla)\n• Filtros dinámicos\n• Auto-guardado de formularios\n\n**Rendimiento:** Reduce llamadas a la API de ~10/s a ~2/s en escritura normal."},"format-date":{"title":"Formateador de Fecha (Intl API)","description":"Formatea fechas sin dependencias usando la Intl API nativa","explanation":"**Formateadores de fecha** usando la Intl API nativa — sin dependencias externas.\n\n**Ventajas de la Intl API:**\n• Nativa del navegador — cero tamaño en el bundle\n• Soporte a cualquier locale automáticamente\n• Funciona en Node.js y navegadores modernos\n\n**formatDate vs moment/date-fns:**\n• moment.js: ~70KB (deprecado)\n• date-fns: ~12KB (tree-shakeable)\n• Intl API: 0KB — ¡ya está en el navegador!\n\n**formatRelative — cuándo usar:**\n• Feeds de actividad, comentarios, notificaciones\n• Cualquier timestamp que necesite ser \"humano\"\n\n**Consejo:** Pasa el locale como parámetro para soportar i18n."},"use-toggle":{"title":"useToggle Hook","description":"Hook para booleanos con acciones nombradas — más legible que useState(false)","explanation":"**useToggle** sustituye useState(false) con una API más expresiva y legible.\n\n**Por qué es mejor que useState puro:**\n• `modal.setTrue` es más claro que `setIsOpen(true)`\n• `favorite.toggle` es más claro que `setFav(v => !v)`\n• Las acciones son useCallback — seguro para pasar como props\n• Destructuring nombrado: `const modal = useToggle()`\n\n**Cuándo usar:**\n• Modales (abrir/cerrar)\n• Dropdowns y menús\n• Favoritos (toggle)\n• Toggle de modo oscuro\n• Cualquier estado booleano\n\n**Patrón:** Devolver objeto en lugar de array permite nombres semánticos sin desestructuración posicional."},"safe-context":{"title":"createSafeContext","description":"Crea context + hook type-safe sin necesidad de comprobar undefined","explanation":"**createSafeContext** elimina el patrón repetitivo de crear context + provider + hook con comprobación de null.\n\n**Problema que resuelve:**\n• Todo createContext<T | undefined>(undefined) exige if (!ctx) throw...\n• Repetir esto en 10+ contexts = boilerplate masivo\n• Fácil olvidar el check y tener error en runtime\n\n**Cómo funciona:**\n• Crea el context con null como default\n• El hook useContextValue hace el null check una sola vez\n• Devuelve [Provider, Hook] como tupla\n\n**Por qué es mejor que el patrón manual:**\n• 0 boilerplate — 1 línea crea Provider + Hook tipado\n• Error descriptivo automático (\"useAuth must be used within AuthProvider\")\n• displayName aparece en React DevTools\n\n**Patrón usado en:** Radix UI, shadcn/ui internals, Chakra UI."},"media-query":{"title":"useMediaQuery (SSR-safe)","description":"Hook responsive que funciona con SSR/Next.js sin hydration mismatch","explanation":"**useMediaQuery** detecta media queries CSS en JavaScript — SSR-safe.\n\n**El truco del SSR:**\n• useState(false) como default — servidor y cliente empiezan igual\n• useEffect sincroniza con el valor real en el cliente\n• Evita hydration mismatch (el error más molesto de Next.js)\n\n**¿Por qué no usar CSS @media directamente?**\n• Cuando la lógica depende del breakpoint (cambiar componente, no solo estilo)\n• Cuando necesitas el valor en JavaScript (analytics, feature flags)\n• Accesibilidad: prefers-reduced-motion para desactivar animaciones\n\n**Presets incluidos:**\n• Breakpoints de Tailwind (sm, md, lg, xl)\n• Modo oscuro y reduced motion\n• Extensible — pasa cualquier string de media query\n\n**Cuidado:** No uses para ocultar contenido visualmente — prefiere CSS para eso (mejor para SEO/accessibility)."},"event-callback":{"title":"useEventCallback","description":"Referencia estable de función sin stale closures — resuelve el bug más común de hooks","explanation":"**useEventCallback** devuelve una función con referencia estable que siempre accede al state más reciente.\n\n**El problema que resuelve:**\n• useCallback con deps = re-crea función = re-subscribe en effects\n• useCallback sin deps = stale closure = lee state antiguo\n• Dilema clásico que genera bugs sutiles en WebSockets, timers, event listeners\n\n**Cómo funciona:**\n• useRef almacena la versión más reciente de la función\n• ref.current se actualiza en cada render (sync)\n• useCallback([], ...) devuelve wrapper estable que llama a ref.current\n• Resultado: referencia estable + closure siempre fresca\n\n**Cuándo usar:**\n• Event handlers pasados a useEffect\n• Callbacks de WebSocket/SSE\n• Timers de larga duración (setInterval)\n• Cualquier lugar donde importen estabilidad + freshness\n\n**Equivalente en React 19:** useEffectEvent (experimental)."},"typed-fetch-zod":{"title":"Typed Fetch + Zod Validation","description":"Fetch type-safe con validación en runtime — single source of truth","explanation":"**typedFetch** combina fetch + Zod para validación en compile time Y runtime.\n\n**Por qué las interfaces de TypeScript no bastan:**\n• La interfaz solo existe en compile time — desaparece en JavaScript\n• Si el backend cambia un campo, TypeScript no protege\n• El crash aparece lejos de la causa real (en el render, no en el fetch)\n\n**Lo que Zod añade:**\n• Validación en runtime — error en el punto exacto del fetch\n• Tipo inferido del schema (z.infer) — single source of truth\n• Mensaje descriptivo: campo, valor esperado vs recibido\n• safeParse no crashea la app — tú decides cómo tratar\n\n**Cuándo usar:**\n• Cualquier fetch de API externa que no controlas\n• APIs internas que cambian con frecuencia\n• Datos críticos (pago, auth, configuración)\n• Integración con terceros (webhooks, APIs públicas)\n\n**Bundle:** Zod ~13KB gzipped — vale cada byte en producción."},"discriminated-props":{"title":"Discriminated Union Props","description":"Patrón TypeScript que hace imposible usar mal las props","explanation":"**Discriminated Union Props** usa el sistema de tipos de TypeScript para hacer imposibles las combinaciones inválidas.\n\n**El problema con props opcionales:**\n• variant=\"link\" con loading={true}? ¿Tiene sentido?\n• href y onClick juntos? ¿Cuál gana?\n• Props opcionales permiten CUALQUIER combinación — bugs silenciosos\n\n**Cómo funciona:**\n• Una propiedad \"discriminante\" (variant) determina qué props existen\n• `never` bloquea props que no tienen sentido en esa variante\n• TypeScript estrecha (type narrowing) dentro del if/switch\n\n**Cuándo usar:**\n• Componentes con múltiples variantes (Button, Input, Modal)\n• Props mutuamente excluyentes (href vs onClick, mode vs config)\n• APIs de componentes que serán usadas por otros devs\n\n**Resultado:** Los errores aparecen en el editor, no en producción. El autocompletado solo muestra props válidas para la variante elegida."},"type-safe-exhaustive":{"title":"Exhaustive Switch Pattern","description":"Patrón que garantiza en compile time que todos los cases de una union han sido tratados","explanation":"**assertNever** es el patrón que garantiza cobertura completa de union types en compile time.\n\n**El problema sin él:**\n• Añades un nuevo status/variant/action en el type\n• Olvidas tratarlo en 3 de los 5 switches del codebase\n• El bug aparece solo en runtime — meses después\n\n**Cómo funciona:**\n• El parámetro es del tipo `never`\n• Si todos los cases están cubiertos, el default es unreachable = tipo `never` = OK\n• Si falta un case, el tipo no es `never` = error en compile time\n\n**Dónde usar:**\n• Reducers (useReducer, Redux)\n• State machines (pago, pedido, auth)\n• Componentes con múltiples variantes\n• Cualquier switch sobre union types\n\n**Patrón adoptado por:** Effect-TS, fp-ts, Prisma, tRPC."}},"comparisons":{"key-prop":{"title":"Index como Key vs Key Estable","category":"React Fundamentals","problem":"Usar index como key en listas causa bugs visuales silenciosos cuando los items se reordenan, eliminan o insertan","issues":["Index cambia cuando los items se reordenan o eliminan","React reutiliza el DOM del index antiguo — el estado visual queda mal","Checkboxes, inputs y animaciones se rompen silenciosamente","Bug solo aparece en runtime — imposible detectar en code review"],"improvements":["Key estable (id) garantiza seguimiento correcto del DOM","Checkboxes, inputs y animaciones preservan estado","Eliminación y reordenación funcionan sin bugs visuales","Regla simple: si el item tiene id, úsalo como key"]},"early-returns":{"title":"Conditional Rendering Limpio","category":"React Patterns","problem":"Ifs anidados y ternarios encadenados hacen el JSX ilegible y difícil de mantener","issues":["Ternarios anidados en 4+ niveles","Difícil rastrear qué condición lleva a qué resultado","Añadir un nuevo estado exige reescribir todo el árbol","Code review se vuelve pesadilla — nadie confía en el diff"],"improvements":["Early returns eliminan todo el anidamiento","Cada estado (loading/error/empty) tratado en 1 línea","Componentes extraídos son testables de forma aislada","Añadir nuevo estado = 1 línea, sin tocar el resto"]},"custom-hooks":{"title":"useEffect Kitchen Sink vs Custom Hooks","category":"React Hooks","problem":"Toda la lógica metida en un useEffect gigante hace el componente intestable e imposible de reutilizar","issues":["useEffect mezcla fetch + localStorage + state — 3 responsabilidades","Imposible testear el fetch separado del componente","Lógica de favoritos no es reutilizable en otras páginas","Componente con 60+ líneas antes del return"],"improvements":["Cada hook tiene 1 responsabilidad — testable con renderHook()","useFavorite reutilizable en cualquier página","AbortController previene race conditions y memory leaks","Componente final tiene ~10 líneas — solo composición"]},"error-handling":{"title":"Try/Catch Genérico vs Error Boundaries + Result Pattern","category":"Error Handling","problem":"Try/catch genérico esconde errores y dificulta el recovery — el usuario ve pantalla en blanco o mensaje inútil","issues":["catch genérico trata network error, 400 y 500 de la misma forma","Mensaje 'Algo salió mal' no ayuda al usuario a resolver","Console.error en producción — nadie lo ve","Sin distinción entre error recuperable y fatal"],"improvements":["Result pattern fuerza tratamiento explícito de éxito y error","Cada tipo de error tiene recovery específico (redirect, retry, field errors)","TypeScript garantiza que todos los tipos de error fueron tratados (exhaustive switch)","Sin throw — flujo predecible, sin sorpresas en producción"]},"zod-validation":{"title":"API sin Validación vs Zod Schema","category":"TypeScript","problem":"Confiar en que la API devuelve el formato correcto causa crashes en producción cuando el backend cambia","issues":["Interfaz TypeScript solo existe en compile time — cero protección en runtime","Backend cambia un campo y el frontend crashea silenciosamente","Error aparece lejos de la causa real (en el .toUpperCase, no en el fetch)","Sin mensaje útil — stack trace apunta al lugar equivocado"],"improvements":["Validación en runtime — catch en el punto exacto del problema","Tipo TypeScript inferido del schema — single source of truth","Mensaje de error descriptivo (campo, valor esperado vs recibido)","safeParse no crashea la app — tú decides cómo tratar"]},"typed-context":{"title":"Estado Diseminado vs Context Tipado","category":"React Patterns","problem":"useState diseminado en múltiples componentes causa desincronización y props drilling","issues":["App component se convierte en 'God component' con todo el estado","Props drilling en cascada — 3+ niveles de repaso","Añadir un nuevo estado global = cambiar 10+ componentes","Imposible saber quién modifica qué — bugs de sincronización"],"improvements":["Estado centralizado con transiciones predecibles (reducer)","Componentes acceden solo a lo que necesitan — cero props drilling","Actions tipadas — imposible dispatch inválido en compile time","useApp() con guard — error claro si se usa fuera del Provider"]}},"patterns":{"share-state":{"question":"Necesito compartir estado entre componentes distantes","pattern":"Context API + useContext","explanation":"Context es la forma nativa de React de evitar prop drilling. Crea un Provider en el nivel más alto necesario y consume con useContext en los componentes que lo necesitan.","when":["Tema, idioma, auth — datos usados en muchos componentes","Evitar pasar props por 3+ niveles","Estado que cambia poco (baja frecuencia de update)"],"avoid":["Estado que cambia a cada tecla (causa re-render en todos los consumers)","Datos que solo 1-2 componentes usan (prop normal basta)"]},"prevent-rerender":{"question":"Mi componente re-renderiza demasiado y la UI está lenta","pattern":"React.memo + useMemo + useCallback","explanation":"React re-renderiza un componente cuando su padre re-renderiza. memo() evita el re-render si las props no cambiaron. useMemo y useCallback estabilizan valores y funciones para que memo funcione.","when":["Listas con 100+ items que re-renderizan sin necesidad","Componentes con cálculos pesados (sort, filter, transform)","Componentes hijos estables que reciben funciones como props"],"avoid":["Optimizar prematuramente — mide primero con React DevTools Profiler","memo() en componentes que SIEMPRE reciben props diferentes","useMemo/useCallback para valores simples (el overhead no compensa)"]},"form-validation":{"question":"Necesito validar formularios complejos con buena UX","pattern":"React Hook Form + Zod","explanation":"React Hook Form gestiona estado del form sin re-renders innecesarios. Zod define el schema de validación e infiere el tipo TypeScript automáticamente.","when":["Formularios con 3+ campos y reglas de validación","Validación en tiempo real (on blur/change)","Formularios que necesitan rendimiento (sin re-render a cada tecla)"],"avoid":["Formularios simples con 1-2 campos (useState basta)","Cuando no necesitas validación client-side"]},"async-state":{"question":"Necesito gestionar estado asíncrono (loading, error, data)","pattern":"TanStack Query (React Query)","explanation":"TanStack Query gestiona todo el ciclo de vida de datos remotos: fetch, cache, revalidación, retry, optimistic updates. Elimina useState + useEffect para fetch de datos.","when":["Cualquier fetch de API que necesita cache y revalidación","Listas con paginación, infinite scroll o polling","Mutations que necesitan actualizar cache local"],"avoid":["Datos estáticos que nunca cambian (importa directo o usa getStaticProps)","Estado puramente client-side (form state, UI toggles)"]},"type-narrowing":{"question":"Necesito manejar diferentes tipos de respuesta de forma segura","pattern":"Discriminated Unions + Type Narrowing","explanation":"Discriminated unions usan una propiedad literal (type, status, kind) para que TypeScript sepa automáticamente qué variante es cuál dentro de un switch/if.","when":["Respuestas de API con múltiples formatos (success/error/loading)","Componentes con variantes mutuamente exclusivas","State machines (pedido: pendiente → procesando → completado → cancelado)"],"avoid":["Cuando el tipo es simple y no tiene variantes (usa type guard simple)","Cuando todas las propiedades están siempre presentes (interfaz normal basta)"]},"render-optimization":{"question":"Necesito renderizar una lista con miles de items","pattern":"Virtualización con TanStack Virtual","explanation":"Virtualización solo renderiza los items visibles en el viewport. En lugar de 10.000 nodos DOM, renderiza ~20. La diferencia de rendimiento es brutal.","when":["Listas con 500+ items (tablas, feeds, logs)","Cuando el scroll se vuelve lento o con jank","Listas con items de altura variable (estimateSize)"],"avoid":["Listas con menos de ~100 items (overhead no compensa)","Cuando necesitas SEO en todos los items (virtualización los oculta al crawler)"]},"conditional-style":{"question":"Necesito aplicar estilos condicionales sin ensuciar el JSX","pattern":"clsx/cn + Tailwind Variants","explanation":"La función cn() (clsx + tailwind-merge) concatena clases condicionalmente y resuelve conflictos de Tailwind. Es el estándar usado por shadcn/ui y toda la comunidad Tailwind.","when":["Cualquier componente con estilos que cambian por estado o prop","Componentes reutilizables que necesitan aceptar className externo","Sistemas de diseño con múltiples variantes (button, badge, alert)"],"avoid":["Estilos que nunca cambian (usa clases estáticas directo)","Lógica de estilo muy compleja (considera CSS Modules o styled-components)"]},"fetch-data":{"question":"¿Cuál es la mejor forma de buscar datos en un componente?","pattern":"useEffect + fetch (básico) o Server Components (Next.js)","explanation":"Para buscar datos, usa useEffect con fetch en componentes client-side, o aprovecha Server Components de Next.js para buscar en el servidor sin JavaScript en el cliente.","when":["Cualquier componente que necesita mostrar datos de una API","Server Components: datos estáticos o que pueden buscarse en el servidor","Client Components: datos que dependen de interacción del usuario"],"avoid":["Fetch dentro de event handlers (usa para acciones, no para datos iniciales)","Fetch sin AbortController en useEffect (causa memory leaks)"]},"error-recovery":{"question":"¿Cómo implementar error recovery amigable en producción?","pattern":"Error Boundaries + Suspense + Retry Pattern","explanation":"Combina Error Boundaries para catch de errores de render, Suspense para loading states, y un retry pattern para dar al usuario la opción de intentar de nuevo sin recargar la página.","when":["Dashboards con múltiples secciones independientes","Componentes que dependen de APIs externas (pueden fallar)","Cualquier app en producción que necesita resiliencia"],"avoid":["Errores en event handlers (Error Boundaries no los capturan — usa try/catch)","Errores en código asíncrono fuera del render (usa Result pattern)"]}},"quickTips":{"key-unique":{"tip":"Nunca uses index como key en listas que cambian","detail":"Usa un ID único y estable (como id de la base de datos). Index causa bugs visuales silenciosos cuando los items se reordenan o eliminan — React reutiliza el DOM equivocado.","category":"React"},"optional-chaining":{"tip":"Usa optional chaining (?.) en lugar de && encadenado","detail":"user?.address?.city es más limpio y seguro que user && user.address && user.address.city. Funciona con llamadas de función también: obj.method?.()","category":"JavaScript"},"fragment-div":{"tip":"Usa <></> en lugar de <div> cuando solo necesitas agrupar JSX","detail":"Los Fragments no crean nodo extra en el DOM. Divs innecesarias rompen layouts CSS (flex, grid) y contaminan el árbol DOM sin razón.","category":"React"},"const-let":{"tip":"Prefiere const siempre — solo usa let cuando realmente necesitas reasignar","detail":"const comunica intención: ese valor no cambia. Facilita code review y evita reasignaciones accidentales. En ~95% de los casos, const es suficiente.","category":"JavaScript"},"updater-function":{"tip":"Usa updater function en setState cuando depende del valor anterior","detail":"setCount(count + 1) puede usar valor stale en batched updates. setCount(prev => prev + 1) siempre usa el valor más reciente. Esencial en event handlers asíncronos.","category":"React"},"abort-controller":{"tip":"Siempre usa AbortController en fetches dentro de useEffect","detail":"Sin abort, cambiar de página rápidamente causa race conditions — la respuesta del fetch anterior sobrescribe la nueva. AbortController cancela requests pendientes en el cleanup.","category":"Performance"},"as-const":{"tip":"Usa 'as const' para inferir tipos literales en lugar de string genérico","detail":"const roles = ['admin', 'user'] as const infiere tipo readonly ['admin', 'user'] en lugar de string[]. Permite extraer union types: type Role = typeof roles[number]","category":"TypeScript"},"error-boundary":{"tip":"Siempre envuelve rutas y secciones independientes con Error Boundaries","detail":"Un error en un componente hijo derrumba todo el árbol React. Error Boundaries aíslan los crashes — la sidebar puede romperse sin derrumbar la página entera.","category":"React"},"barrel-files":{"tip":"Evita barrel files (index.ts) en proyectos grandes — matan el tree-shaking","detail":"Importar de un index.ts fuerza al bundler a evaluar todos los re-exports. En monorepos, esto puede añadir cientos de KB al bundle. Importa directo del archivo fuente.","category":"Architecture"},"server-components":{"tip":"Los componentes que solo muestran datos deben ser Server Components — no añadas 'use client' sin necesidad","detail":"Server Components se ejecutan en el servidor = cero JavaScript en el bundle del cliente. Solo añade 'use client' cuando necesitas hooks, event handlers o browser APIs.","category":"Next.js"},"composition-over-config":{"tip":"Prefiere composición sobre configuración en componentes públicos","detail":"En lugar de <Card showHeader showFooter headerTitle='...' footerAction='...'>, usa <Card><CardHeader>...</CardHeader><CardFooter>...</CardFooter></Card>. Más flexible, tipado y extensible.","category":"Patterns"},"use-sync-external-store":{"tip":"Usa useSyncExternalStore para integrar stores externos con React 18+","detail":"Es el hook oficial para sincronizar React con cualquier fuente de datos externa (localStorage, WebSocket, Redux-like stores). Garantiza consistencia con concurrent rendering.","category":"React"}}}
